# This file was autogenerated using quicktype https://github.com/quicktype/quicktype
#
# Add Jason to your mix.exs
#
# Decode a JSON string: Ldtk.Root.from_json(data)
# Encode into a JSON string: Ldtk.Root.to_json(struct)

defmodule Ldtk.WhenEnum do
  @moduledoc """
  Possible values: `Manual`, `AfterLoad`, `BeforeSave`, `AfterSave`
  """
  @valid_enum_members [
    :AfterLoad,
    :AfterSave,
    :BeforeSave,
    :Manual
  ]

  def valid_atom?(value), do: value in @valid_enum_members

  def valid_atom_string?(value) do
    try do
      atom = String.to_existing_atom(value)
      atom in @valid_enum_members
    rescue
      ArgumentError -> false
    end
  end

  def encode(value) do
    if valid_atom?(value) do
      Atom.to_string(value)
    else
      {:error, "Unexpected value when encoding atom: #{inspect(value)}"}
    end
  end

  def decode(value) do
    if valid_atom_string?(value) do
      String.to_existing_atom(value)
    else
      {:error, "Unexpected value when decoding atom: #{inspect(value)}"}
    end
  end

  def from_json(json) do
    json
    |> Jason.decode!()
    |> decode()
  end

  def to_json(data) do
    data
    |> encode()
    |> Jason.encode!()
  end
end

defmodule Ldtk.LdtkCustomCommand do
  @moduledoc """
  - `:ldtk_custom_command_when` - Possible values: `Manual`, `AfterLoad`, `BeforeSave`, `AfterSave`
  """

  @enforce_keys [:command, :ldtk_custom_command_when]
  defstruct [:command, :ldtk_custom_command_when]

  @type t :: %__MODULE__{
          command: String.t(),
          ldtk_custom_command_when: Ldtk.WhenEnum.t()
        }

  def from_map(m) do
    %Ldtk.LdtkCustomCommand{
      command: m["command"],
      ldtk_custom_command_when: Ldtk.WhenEnum.decode(m["when"])
    }
  end

  def from_json(json) do
    json
    |> Jason.decode!()
    |> from_map()
  end

  def to_map(struct) do
    %{
      "command" => struct.command,
      "when" => Ldtk.WhenEnum.encode(struct.ldtk_custom_command_when)
    }
  end

  def to_json(struct) do
    struct
    |> to_map()
    |> Jason.encode!()
  end
end

defmodule Ldtk.AllowedRefs do
  @moduledoc """
  Possible values: `Any`, `OnlySame`, `OnlyTags`, `OnlySpecificEntity`
  """
  @valid_enum_members [
    :Any,
    :OnlySame,
    :OnlySpecificEntity,
    :OnlyTags
  ]

  def valid_atom?(value), do: value in @valid_enum_members

  def valid_atom_string?(value) do
    try do
      atom = String.to_existing_atom(value)
      atom in @valid_enum_members
    rescue
      ArgumentError -> false
    end
  end

  def encode(value) do
    if valid_atom?(value) do
      Atom.to_string(value)
    else
      {:error, "Unexpected value when encoding atom: #{inspect(value)}"}
    end
  end

  def decode(value) do
    if valid_atom_string?(value) do
      String.to_existing_atom(value)
    else
      {:error, "Unexpected value when decoding atom: #{inspect(value)}"}
    end
  end

  def from_json(json) do
    json
    |> Jason.decode!()
    |> decode()
  end

  def to_json(data) do
    data
    |> encode()
    |> Jason.encode!()
  end
end

defmodule Ldtk.EditorDisplayMode do
  @moduledoc """
  Possible values: `Hidden`, `ValueOnly`, `NameAndValue`, `EntityTile`, `LevelTile`,
  `Points`, `PointStar`, `PointPath`, `PointPathLoop`, `RadiusPx`, `RadiusGrid`,
  `ArrayCountWithLabel`, `ArrayCountNoLabel`, `RefLinkBetweenPivots`,
  `RefLinkBetweenCenters`
  """
  @valid_enum_members [
    :ArrayCountNoLabel,
    :ArrayCountWithLabel,
    :EntityTile,
    :Hidden,
    :LevelTile,
    :NameAndValue,
    :PointPath,
    :PointPathLoop,
    :PointStar,
    :Points,
    :RadiusGrid,
    :RadiusPx,
    :RefLinkBetweenCenters,
    :RefLinkBetweenPivots,
    :ValueOnly
  ]

  def valid_atom?(value), do: value in @valid_enum_members

  def valid_atom_string?(value) do
    try do
      atom = String.to_existing_atom(value)
      atom in @valid_enum_members
    rescue
      ArgumentError -> false
    end
  end

  def encode(value) do
    if valid_atom?(value) do
      Atom.to_string(value)
    else
      {:error, "Unexpected value when encoding atom: #{inspect(value)}"}
    end
  end

  def decode(value) do
    if valid_atom_string?(value) do
      String.to_existing_atom(value)
    else
      {:error, "Unexpected value when decoding atom: #{inspect(value)}"}
    end
  end

  def from_json(json) do
    json
    |> Jason.decode!()
    |> decode()
  end

  def to_json(data) do
    data
    |> encode()
    |> Jason.encode!()
  end
end

defmodule Ldtk.EditorDisplayPos do
  @moduledoc """
  Possible values: `Above`, `Center`, `Beneath`
  """
  @valid_enum_members [
    :Above,
    :Beneath,
    :Center
  ]

  def valid_atom?(value), do: value in @valid_enum_members

  def valid_atom_string?(value) do
    try do
      atom = String.to_existing_atom(value)
      atom in @valid_enum_members
    rescue
      ArgumentError -> false
    end
  end

  def encode(value) do
    if valid_atom?(value) do
      Atom.to_string(value)
    else
      {:error, "Unexpected value when encoding atom: #{inspect(value)}"}
    end
  end

  def decode(value) do
    if valid_atom_string?(value) do
      String.to_existing_atom(value)
    else
      {:error, "Unexpected value when decoding atom: #{inspect(value)}"}
    end
  end

  def from_json(json) do
    json
    |> Jason.decode!()
    |> decode()
  end

  def to_json(data) do
    data
    |> encode()
    |> Jason.encode!()
  end
end

defmodule Ldtk.EditorLinkStyle do
  @moduledoc """
  Possible values: `ZigZag`, `StraightArrow`, `CurvedArrow`, `ArrowsLine`, `DashedLine`
  """
  @valid_enum_members [
    :ArrowsLine,
    :CurvedArrow,
    :DashedLine,
    :StraightArrow,
    :ZigZag
  ]

  def valid_atom?(value), do: value in @valid_enum_members

  def valid_atom_string?(value) do
    try do
      atom = String.to_existing_atom(value)
      atom in @valid_enum_members
    rescue
      ArgumentError -> false
    end
  end

  def encode(value) do
    if valid_atom?(value) do
      Atom.to_string(value)
    else
      {:error, "Unexpected value when encoding atom: #{inspect(value)}"}
    end
  end

  def decode(value) do
    if valid_atom_string?(value) do
      String.to_existing_atom(value)
    else
      {:error, "Unexpected value when decoding atom: #{inspect(value)}"}
    end
  end

  def from_json(json) do
    json
    |> Jason.decode!()
    |> decode()
  end

  def to_json(data) do
    data
    |> encode()
    |> Jason.encode!()
  end
end

defmodule Ldtk.TextLanguageMode do
  @valid_enum_members [
    :LangC,
    :LangHaxe,
    :LangJS,
    :LangJson,
    :LangLog,
    :LangLua,
    :LangMarkdown,
    :LangPython,
    :LangRuby,
    :LangXml
  ]

  def valid_atom?(value), do: value in @valid_enum_members

  def valid_atom_string?(value) do
    try do
      atom = String.to_existing_atom(value)
      atom in @valid_enum_members
    rescue
      ArgumentError -> false
    end
  end

  def encode(value) do
    if valid_atom?(value) do
      Atom.to_string(value)
    else
      {:error, "Unexpected value when encoding atom: #{inspect(value)}"}
    end
  end

  def decode(value) do
    if valid_atom_string?(value) do
      String.to_existing_atom(value)
    else
      {:error, "Unexpected value when decoding atom: #{inspect(value)}"}
    end
  end

  def from_json(json) do
    json
    |> Jason.decode!()
    |> decode()
  end

  def to_json(data) do
    data
    |> encode()
    |> Jason.encode!()
  end
end

defmodule Ldtk.FieldDefinition do
  @moduledoc """
  This section is mostly only intended for the LDtk editor app itself. You can safely
  ignore it.
  - `:type` - Human readable value type. Possible values: `Int, Float, String, Bool, Color,ExternEnum.XXX, LocalEnum.XXX, Point, FilePath`.<br/>  If the field is an array, thisfield will look like `Array<...>` (eg. `Array<Int>`, `Array<Point>` etc.)<br/>  NOTE: ifyou enable the advanced option **Use Multilines type**, you will have "*Multilines*"instead of "*String*" when relevant.
  - `:accept_file_types` - Optional list of accepted file extensions for FilePath value type. Includes the dot:`.ext`
  - `:allowed_refs` - Possible values: `Any`, `OnlySame`, `OnlyTags`, `OnlySpecificEntity`
  - `:array_max_length` - Array max length
  - `:array_min_length` - Array min length
  - `:can_be_null` - TRUE if the value can be null. For arrays, TRUE means it can contain null values(exception: array of Points can't have null values).
  - `:default_override` - Default value if selected value is null or invalid.
  - `:doc` - User defined documentation for this field to provide help/tips to level designers aboutaccepted values.
  - `:editor_display_mode` - Possible values: `Hidden`, `ValueOnly`, `NameAndValue`, `EntityTile`, `LevelTile`,`Points`, `PointStar`, `PointPath`, `PointPathLoop`, `RadiusPx`, `RadiusGrid`,`ArrayCountWithLabel`, `ArrayCountNoLabel`, `RefLinkBetweenPivots`,`RefLinkBetweenCenters`
  - `:editor_display_pos` - Possible values: `Above`, `Center`, `Beneath`
  - `:editor_link_style` - Possible values: `ZigZag`, `StraightArrow`, `CurvedArrow`, `ArrowsLine`, `DashedLine`
  - `:export_to_toc` - If TRUE, the field value will be exported to the `toc` project JSON field. Only appliesto Entity fields.
  - `:identifier` - User defined unique identifier
  - `:is_array` - TRUE if the value is an array of multiple values
  - `:max` - Max limit for value, if applicable
  - `:min` - Min limit for value, if applicable
  - `:regex` - Optional regular expression that needs to be matched to accept values. Expected format:`/some_reg_ex/g`, with optional "i" flag.
  - `:searchable` - If enabled, this field will be searchable through LDtk command palette
  - `:text_language_mode` - Possible values: &lt;`null`&gt;, `LangPython`, `LangRuby`, `LangJS`, `LangLua`, `LangC`,`LangHaxe`, `LangMarkdown`, `LangJson`, `LangXml`, `LangLog`
  - `:tileset_uid` - UID of the tileset used for a Tile
  - `:field_definition_type` - Internal enum representing the possible field types. Possible values: F_Int, F_Float,F_String, F_Text, F_Bool, F_Color, F_Enum(...), F_Point, F_Path, F_EntityRef, F_Tile
  - `:uid` - Unique Int identifier
  - `:use_for_smart_color` - If TRUE, the color associated with this field will override the Entity or Level defaultcolor in the editor UI. For Enum fields, this would be the color associated to theirvalues.
  """

  @enforce_keys [
    :type,
    :allowed_refs,
    :allowed_ref_tags,
    :allow_out_of_level_ref,
    :auto_chain_ref,
    :can_be_null,
    :editor_always_show,
    :editor_cut_long_values,
    :editor_display_mode,
    :editor_display_pos,
    :editor_display_scale,
    :editor_link_style,
    :editor_show_in_world,
    :export_to_toc,
    :identifier,
    :is_array,
    :searchable,
    :symmetrical_ref,
    :field_definition_type,
    :uid,
    :use_for_smart_color
  ]
  defstruct [
    :type,
    :accept_file_types,
    :allowed_refs,
    :allowed_refs_entity_uid,
    :allowed_ref_tags,
    :allow_out_of_level_ref,
    :array_max_length,
    :array_min_length,
    :auto_chain_ref,
    :can_be_null,
    :default_override,
    :doc,
    :editor_always_show,
    :editor_cut_long_values,
    :editor_display_color,
    :editor_display_mode,
    :editor_display_pos,
    :editor_display_scale,
    :editor_link_style,
    :editor_show_in_world,
    :editor_text_prefix,
    :editor_text_suffix,
    :export_to_toc,
    :identifier,
    :is_array,
    :max,
    :min,
    :regex,
    :searchable,
    :symmetrical_ref,
    :text_language_mode,
    :tileset_uid,
    :field_definition_type,
    :uid,
    :use_for_smart_color
  ]

  @type t :: %__MODULE__{
          type: String.t(),
          accept_file_types: [String.t()] | nil | nil,
          allowed_refs: Ldtk.AllowedRefs.t(),
          allowed_refs_entity_uid: integer() | nil | nil,
          allowed_ref_tags: [String.t()],
          allow_out_of_level_ref: boolean(),
          array_max_length: integer() | nil | nil,
          array_min_length: integer() | nil | nil,
          auto_chain_ref: boolean(),
          can_be_null: boolean(),
          default_override: any() | nil,
          doc: nil | String.t() | nil,
          editor_always_show: boolean(),
          editor_cut_long_values: boolean(),
          editor_display_color: nil | String.t() | nil,
          editor_display_mode: Ldtk.EditorDisplayMode.t(),
          editor_display_pos: Ldtk.EditorDisplayPos.t(),
          editor_display_scale: float(),
          editor_link_style: Ldtk.EditorLinkStyle.t(),
          editor_show_in_world: boolean(),
          editor_text_prefix: nil | String.t() | nil,
          editor_text_suffix: nil | String.t() | nil,
          export_to_toc: boolean(),
          identifier: String.t(),
          is_array: boolean(),
          max: float() | nil | nil,
          min: float() | nil | nil,
          regex: nil | String.t() | nil,
          searchable: boolean(),
          symmetrical_ref: boolean(),
          text_language_mode: Ldtk.TextLanguageMode.t() | nil | nil,
          tileset_uid: integer() | nil | nil,
          field_definition_type: String.t(),
          uid: integer(),
          use_for_smart_color: boolean()
        }

  def from_map(m) do
    %Ldtk.FieldDefinition{
      type: m["__type"],
      accept_file_types: m["acceptFileTypes"],
      allowed_refs: Ldtk.AllowedRefs.decode(m["allowedRefs"]),
      allowed_refs_entity_uid: m["allowedRefsEntityUid"],
      allowed_ref_tags: m["allowedRefTags"],
      allow_out_of_level_ref: m["allowOutOfLevelRef"],
      array_max_length: m["arrayMaxLength"],
      array_min_length: m["arrayMinLength"],
      auto_chain_ref: m["autoChainRef"],
      can_be_null: m["canBeNull"],
      default_override: m["defaultOverride"],
      doc: m["doc"],
      editor_always_show: m["editorAlwaysShow"],
      editor_cut_long_values: m["editorCutLongValues"],
      editor_display_color: m["editorDisplayColor"],
      editor_display_mode: Ldtk.EditorDisplayMode.decode(m["editorDisplayMode"]),
      editor_display_pos: Ldtk.EditorDisplayPos.decode(m["editorDisplayPos"]),
      editor_display_scale: m["editorDisplayScale"],
      editor_link_style: Ldtk.EditorLinkStyle.decode(m["editorLinkStyle"]),
      editor_show_in_world: m["editorShowInWorld"],
      editor_text_prefix: m["editorTextPrefix"],
      editor_text_suffix: m["editorTextSuffix"],
      export_to_toc: m["exportToToc"],
      identifier: m["identifier"],
      is_array: m["isArray"],
      max: m["max"],
      min: m["min"],
      regex: m["regex"],
      searchable: m["searchable"],
      symmetrical_ref: m["symmetricalRef"],
      text_language_mode:
        m["textLanguageMode"] && Ldtk.TextLanguageMode.decode(m["textLanguageMode"]),
      tileset_uid: m["tilesetUid"],
      field_definition_type: m["type"],
      uid: m["uid"],
      use_for_smart_color: m["useForSmartColor"]
    }
  end

  def from_json(json) do
    json
    |> Jason.decode!()
    |> from_map()
  end

  def to_map(struct) do
    %{
      "__type" => struct.type,
      "acceptFileTypes" => struct.accept_file_types,
      "allowedRefs" => Ldtk.AllowedRefs.encode(struct.allowed_refs),
      "allowedRefsEntityUid" => struct.allowed_refs_entity_uid,
      "allowedRefTags" => struct.allowed_ref_tags,
      "allowOutOfLevelRef" => struct.allow_out_of_level_ref,
      "arrayMaxLength" => struct.array_max_length,
      "arrayMinLength" => struct.array_min_length,
      "autoChainRef" => struct.auto_chain_ref,
      "canBeNull" => struct.can_be_null,
      "defaultOverride" => struct.default_override,
      "doc" => struct.doc,
      "editorAlwaysShow" => struct.editor_always_show,
      "editorCutLongValues" => struct.editor_cut_long_values,
      "editorDisplayColor" => struct.editor_display_color,
      "editorDisplayMode" => Ldtk.EditorDisplayMode.encode(struct.editor_display_mode),
      "editorDisplayPos" => Ldtk.EditorDisplayPos.encode(struct.editor_display_pos),
      "editorDisplayScale" => struct.editor_display_scale,
      "editorLinkStyle" => Ldtk.EditorLinkStyle.encode(struct.editor_link_style),
      "editorShowInWorld" => struct.editor_show_in_world,
      "editorTextPrefix" => struct.editor_text_prefix,
      "editorTextSuffix" => struct.editor_text_suffix,
      "exportToToc" => struct.export_to_toc,
      "identifier" => struct.identifier,
      "isArray" => struct.is_array,
      "max" => struct.max,
      "min" => struct.min,
      "regex" => struct.regex,
      "searchable" => struct.searchable,
      "symmetricalRef" => struct.symmetrical_ref,
      "textLanguageMode" =>
        struct.text_language_mode && Ldtk.TextLanguageMode.encode(struct.text_language_mode),
      "tilesetUid" => struct.tileset_uid,
      "type" => struct.field_definition_type,
      "uid" => struct.uid,
      "useForSmartColor" => struct.use_for_smart_color
    }
  end

  def to_json(struct) do
    struct
    |> to_map()
    |> Jason.encode!()
  end
end

defmodule Ldtk.LimitBehavior do
  @moduledoc """
  Possible values: `DiscardOldOnes`, `PreventAdding`, `MoveLastOne`
  """
  @valid_enum_members [
    :DiscardOldOnes,
    :MoveLastOne,
    :PreventAdding
  ]

  def valid_atom?(value), do: value in @valid_enum_members

  def valid_atom_string?(value) do
    try do
      atom = String.to_existing_atom(value)
      atom in @valid_enum_members
    rescue
      ArgumentError -> false
    end
  end

  def encode(value) do
    if valid_atom?(value) do
      Atom.to_string(value)
    else
      {:error, "Unexpected value when encoding atom: #{inspect(value)}"}
    end
  end

  def decode(value) do
    if valid_atom_string?(value) do
      String.to_existing_atom(value)
    else
      {:error, "Unexpected value when decoding atom: #{inspect(value)}"}
    end
  end

  def from_json(json) do
    json
    |> Jason.decode!()
    |> decode()
  end

  def to_json(data) do
    data
    |> encode()
    |> Jason.encode!()
  end
end

defmodule Ldtk.LimitScope do
  @moduledoc """
  If TRUE, the maxCount is a "per world" limit, if FALSE, it's a "per level". Possible
  values: `PerLayer`, `PerLevel`, `PerWorld`
  """
  @valid_enum_members [
    :PerLayer,
    :PerLevel,
    :PerWorld
  ]

  def valid_atom?(value), do: value in @valid_enum_members

  def valid_atom_string?(value) do
    try do
      atom = String.to_existing_atom(value)
      atom in @valid_enum_members
    rescue
      ArgumentError -> false
    end
  end

  def encode(value) do
    if valid_atom?(value) do
      Atom.to_string(value)
    else
      {:error, "Unexpected value when encoding atom: #{inspect(value)}"}
    end
  end

  def decode(value) do
    if valid_atom_string?(value) do
      String.to_existing_atom(value)
    else
      {:error, "Unexpected value when decoding atom: #{inspect(value)}"}
    end
  end

  def from_json(json) do
    json
    |> Jason.decode!()
    |> decode()
  end

  def to_json(data) do
    data
    |> encode()
    |> Jason.encode!()
  end
end

defmodule Ldtk.RenderMode do
  @moduledoc """
  Possible values: `Rectangle`, `Ellipse`, `Tile`, `Cross`
  """
  @valid_enum_members [
    :Cross,
    :Ellipse,
    :Rectangle,
    :Tile
  ]

  def valid_atom?(value), do: value in @valid_enum_members

  def valid_atom_string?(value) do
    try do
      atom = String.to_existing_atom(value)
      atom in @valid_enum_members
    rescue
      ArgumentError -> false
    end
  end

  def encode(value) do
    if valid_atom?(value) do
      Atom.to_string(value)
    else
      {:error, "Unexpected value when encoding atom: #{inspect(value)}"}
    end
  end

  def decode(value) do
    if valid_atom_string?(value) do
      String.to_existing_atom(value)
    else
      {:error, "Unexpected value when decoding atom: #{inspect(value)}"}
    end
  end

  def from_json(json) do
    json
    |> Jason.decode!()
    |> decode()
  end

  def to_json(data) do
    data
    |> encode()
    |> Jason.encode!()
  end
end

defmodule Ldtk.TilesetRectangle do
  @moduledoc """
  This object represents a custom sub rectangle in a Tileset image.
  - `:h` - Height in pixels
  - `:tileset_uid` - UID of the tileset
  - `:w` - Width in pixels
  - `:x` - X pixels coordinate of the top-left corner in the Tileset image
  - `:y` - Y pixels coordinate of the top-left corner in the Tileset image
  """

  @enforce_keys [:h, :tileset_uid, :w, :x, :y]
  defstruct [:h, :tileset_uid, :w, :x, :y]

  @type t :: %__MODULE__{
          h: integer(),
          tileset_uid: integer(),
          w: integer(),
          x: integer(),
          y: integer()
        }

  def from_map(m) do
    %Ldtk.TilesetRectangle{
      h: m["h"],
      tileset_uid: m["tilesetUid"],
      w: m["w"],
      x: m["x"],
      y: m["y"]
    }
  end

  def from_json(json) do
    json
    |> Jason.decode!()
    |> from_map()
  end

  def to_map(struct) do
    %{
      "h" => struct.h,
      "tilesetUid" => struct.tileset_uid,
      "w" => struct.w,
      "x" => struct.x,
      "y" => struct.y
    }
  end

  def to_json(struct) do
    struct
    |> to_map()
    |> Jason.encode!()
  end
end

defmodule Ldtk.TileRenderMode do
  @moduledoc """
  An enum describing how the the Entity tile is rendered inside the Entity bounds. Possible
  values: `Cover`, `FitInside`, `Repeat`, `Stretch`, `FullSizeCropped`,
  `FullSizeUncropped`, `NineSlice`
  """
  @valid_enum_members [
    :Cover,
    :FitInside,
    :FullSizeCropped,
    :FullSizeUncropped,
    :NineSlice,
    :Repeat,
    :Stretch
  ]

  def valid_atom?(value), do: value in @valid_enum_members

  def valid_atom_string?(value) do
    try do
      atom = String.to_existing_atom(value)
      atom in @valid_enum_members
    rescue
      ArgumentError -> false
    end
  end

  def encode(value) do
    if valid_atom?(value) do
      Atom.to_string(value)
    else
      {:error, "Unexpected value when encoding atom: #{inspect(value)}"}
    end
  end

  def decode(value) do
    if valid_atom_string?(value) do
      String.to_existing_atom(value)
    else
      {:error, "Unexpected value when decoding atom: #{inspect(value)}"}
    end
  end

  def from_json(json) do
    json
    |> Jason.decode!()
    |> decode()
  end

  def to_json(data) do
    data
    |> encode()
    |> Jason.encode!()
  end
end

defmodule Ldtk.EntityDefinition do
  @moduledoc """
  - `:allow_out_of_bounds` - If enabled, this entity is allowed to stay outside of the current level bounds
  - `:color` - Base entity color
  - `:doc` - User defined documentation for this element to provide help/tips to level designers.
  - `:export_to_toc` - If enabled, all instances of this entity will be listed in the project "Table of content"object.
  - `:field_defs` - Array of field definitions
  - `:height` - Pixel height
  - `:identifier` - User defined unique identifier
  - `:keep_aspect_ratio` - Only applies to entities resizable on both X/Y. If TRUE, the entity instance width/heightwill keep the same aspect ratio as the definition.
  - `:limit_behavior` - Possible values: `DiscardOldOnes`, `PreventAdding`, `MoveLastOne`
  - `:limit_scope` - If TRUE, the maxCount is a "per world" limit, if FALSE, it's a "per level". Possiblevalues: `PerLayer`, `PerLevel`, `PerWorld`
  - `:max_count` - Max instances count
  - `:max_height` - Max pixel height (only applies if the entity is resizable on Y)
  - `:max_width` - Max pixel width (only applies if the entity is resizable on X)
  - `:min_height` - Min pixel height (only applies if the entity is resizable on Y)
  - `:min_width` - Min pixel width (only applies if the entity is resizable on X)
  - `:nine_slice_borders` - An array of 4 dimensions for the up/right/down/left borders (in this order) when using9-slice mode for `tileRenderMode`.<br/>  If the tileRenderMode is not NineSlice, thenthis array is empty.<br/>  See: https://en.wikipedia.org/wiki/9-slice_scaling
  - `:pivot_x` - Pivot X coordinate (from 0 to 1.0)
  - `:pivot_y` - Pivot Y coordinate (from 0 to 1.0)
  - `:render_mode` - Possible values: `Rectangle`, `Ellipse`, `Tile`, `Cross`
  - `:resizable_x` - If TRUE, the entity instances will be resizable horizontally
  - `:resizable_y` - If TRUE, the entity instances will be resizable vertically
  - `:show_name` - Display entity name in editor
  - `:tags` - An array of strings that classifies this entity
  - `:tile_id` - **WARNING**: this deprecated value is no longer exported since version 1.2.0  Replacedby: `tileRect`
  - `:tile_rect` - An object representing a rectangle from an existing Tileset
  - `:tile_render_mode` - An enum describing how the the Entity tile is rendered inside the Entity bounds. Possiblevalues: `Cover`, `FitInside`, `Repeat`, `Stretch`, `FullSizeCropped`,`FullSizeUncropped`, `NineSlice`
  - `:tileset_id` - Tileset ID used for optional tile display
  - `:uid` - Unique Int identifier
  - `:ui_tile_rect` - This tile overrides the one defined in `tileRect` in the UI
  - `:width` - Pixel width
  """

  @enforce_keys [
    :allow_out_of_bounds,
    :color,
    :export_to_toc,
    :field_defs,
    :fill_opacity,
    :height,
    :hollow,
    :identifier,
    :keep_aspect_ratio,
    :limit_behavior,
    :limit_scope,
    :line_opacity,
    :max_count,
    :nine_slice_borders,
    :pivot_x,
    :pivot_y,
    :render_mode,
    :resizable_x,
    :resizable_y,
    :show_name,
    :tags,
    :tile_opacity,
    :tile_render_mode,
    :uid,
    :width
  ]
  defstruct [
    :allow_out_of_bounds,
    :color,
    :doc,
    :export_to_toc,
    :field_defs,
    :fill_opacity,
    :height,
    :hollow,
    :identifier,
    :keep_aspect_ratio,
    :limit_behavior,
    :limit_scope,
    :line_opacity,
    :max_count,
    :max_height,
    :max_width,
    :min_height,
    :min_width,
    :nine_slice_borders,
    :pivot_x,
    :pivot_y,
    :render_mode,
    :resizable_x,
    :resizable_y,
    :show_name,
    :tags,
    :tile_id,
    :tile_opacity,
    :tile_rect,
    :tile_render_mode,
    :tileset_id,
    :uid,
    :ui_tile_rect,
    :width
  ]

  @type t :: %__MODULE__{
          allow_out_of_bounds: boolean(),
          color: String.t(),
          doc: nil | String.t() | nil,
          export_to_toc: boolean(),
          field_defs: [Ldtk.FieldDefinition.t()],
          fill_opacity: float(),
          height: integer(),
          hollow: boolean(),
          identifier: String.t(),
          keep_aspect_ratio: boolean(),
          limit_behavior: Ldtk.LimitBehavior.t(),
          limit_scope: Ldtk.LimitScope.t(),
          line_opacity: float(),
          max_count: integer(),
          max_height: integer() | nil | nil,
          max_width: integer() | nil | nil,
          min_height: integer() | nil | nil,
          min_width: integer() | nil | nil,
          nine_slice_borders: [integer()],
          pivot_x: float(),
          pivot_y: float(),
          render_mode: Ldtk.RenderMode.t(),
          resizable_x: boolean(),
          resizable_y: boolean(),
          show_name: boolean(),
          tags: [String.t()],
          tile_id: integer() | nil | nil,
          tile_opacity: float(),
          tile_rect: Ldtk.TilesetRectangle.t() | nil | nil,
          tile_render_mode: Ldtk.TileRenderMode.t(),
          tileset_id: integer() | nil | nil,
          uid: integer(),
          ui_tile_rect: Ldtk.TilesetRectangle.t() | nil | nil,
          width: integer()
        }

  def from_map(m) do
    %Ldtk.EntityDefinition{
      allow_out_of_bounds: m["allowOutOfBounds"],
      color: m["color"],
      doc: m["doc"],
      export_to_toc: m["exportToToc"],
      field_defs: Enum.map(m["fieldDefs"], &Ldtk.FieldDefinition.from_map/1),
      fill_opacity: m["fillOpacity"],
      height: m["height"],
      hollow: m["hollow"],
      identifier: m["identifier"],
      keep_aspect_ratio: m["keepAspectRatio"],
      limit_behavior: Ldtk.LimitBehavior.decode(m["limitBehavior"]),
      limit_scope: Ldtk.LimitScope.decode(m["limitScope"]),
      line_opacity: m["lineOpacity"],
      max_count: m["maxCount"],
      max_height: m["maxHeight"],
      max_width: m["maxWidth"],
      min_height: m["minHeight"],
      min_width: m["minWidth"],
      nine_slice_borders: m["nineSliceBorders"],
      pivot_x: m["pivotX"],
      pivot_y: m["pivotY"],
      render_mode: Ldtk.RenderMode.decode(m["renderMode"]),
      resizable_x: m["resizableX"],
      resizable_y: m["resizableY"],
      show_name: m["showName"],
      tags: m["tags"],
      tile_id: m["tileId"],
      tile_opacity: m["tileOpacity"],
      tile_rect: m["tileRect"] && Ldtk.TilesetRectangle.from_map(m["tileRect"]),
      tile_render_mode: Ldtk.TileRenderMode.decode(m["tileRenderMode"]),
      tileset_id: m["tilesetId"],
      uid: m["uid"],
      ui_tile_rect: m["uiTileRect"] && Ldtk.TilesetRectangle.from_map(m["uiTileRect"]),
      width: m["width"]
    }
  end

  def from_json(json) do
    json
    |> Jason.decode!()
    |> from_map()
  end

  def to_map(struct) do
    %{
      "allowOutOfBounds" => struct.allow_out_of_bounds,
      "color" => struct.color,
      "doc" => struct.doc,
      "exportToToc" => struct.export_to_toc,
      "fieldDefs" =>
        struct.field_defs && Enum.map(struct.field_defs, &Ldtk.FieldDefinition.to_map/1),
      "fillOpacity" => struct.fill_opacity,
      "height" => struct.height,
      "hollow" => struct.hollow,
      "identifier" => struct.identifier,
      "keepAspectRatio" => struct.keep_aspect_ratio,
      "limitBehavior" => Ldtk.LimitBehavior.encode(struct.limit_behavior),
      "limitScope" => Ldtk.LimitScope.encode(struct.limit_scope),
      "lineOpacity" => struct.line_opacity,
      "maxCount" => struct.max_count,
      "maxHeight" => struct.max_height,
      "maxWidth" => struct.max_width,
      "minHeight" => struct.min_height,
      "minWidth" => struct.min_width,
      "nineSliceBorders" => struct.nine_slice_borders,
      "pivotX" => struct.pivot_x,
      "pivotY" => struct.pivot_y,
      "renderMode" => Ldtk.RenderMode.encode(struct.render_mode),
      "resizableX" => struct.resizable_x,
      "resizableY" => struct.resizable_y,
      "showName" => struct.show_name,
      "tags" => struct.tags,
      "tileId" => struct.tile_id,
      "tileOpacity" => struct.tile_opacity,
      "tileRect" => struct.tile_rect && Ldtk.TilesetRectangle.to_map(struct.tile_rect),
      "tileRenderMode" => Ldtk.TileRenderMode.encode(struct.tile_render_mode),
      "tilesetId" => struct.tileset_id,
      "uid" => struct.uid,
      "uiTileRect" => struct.ui_tile_rect && Ldtk.TilesetRectangle.to_map(struct.ui_tile_rect),
      "width" => struct.width
    }
  end

  def to_json(struct) do
    struct
    |> to_map()
    |> Jason.encode!()
  end
end

defmodule Ldtk.EnumValueDefinition do
  @moduledoc """
  - `:tile_src_rect` - **WARNING**: this deprecated value is no longer exported since version 1.4.0  Replacedby: `tileRect`
  - `:color` - Optional color
  - `:id` - Enum value
  - `:tile_id` - **WARNING**: this deprecated value is no longer exported since version 1.4.0  Replacedby: `tileRect`
  - `:tile_rect` - Optional tileset rectangle to represents this value
  """

  @enforce_keys [:color, :id]
  defstruct [:tile_src_rect, :color, :id, :tile_id, :tile_rect]

  @type t :: %__MODULE__{
          tile_src_rect: [integer()] | nil | nil,
          color: integer(),
          id: String.t(),
          tile_id: integer() | nil | nil,
          tile_rect: Ldtk.TilesetRectangle.t() | nil | nil
        }

  def from_map(m) do
    %Ldtk.EnumValueDefinition{
      tile_src_rect: m["__tileSrcRect"],
      color: m["color"],
      id: m["id"],
      tile_id: m["tileId"],
      tile_rect: m["tileRect"] && Ldtk.TilesetRectangle.from_map(m["tileRect"])
    }
  end

  def from_json(json) do
    json
    |> Jason.decode!()
    |> from_map()
  end

  def to_map(struct) do
    %{
      "__tileSrcRect" => struct.tile_src_rect,
      "color" => struct.color,
      "id" => struct.id,
      "tileId" => struct.tile_id,
      "tileRect" => struct.tile_rect && Ldtk.TilesetRectangle.to_map(struct.tile_rect)
    }
  end

  def to_json(struct) do
    struct
    |> to_map()
    |> Jason.encode!()
  end
end

defmodule Ldtk.EnumDefinition do
  @moduledoc """
  - `:external_rel_path` - Relative path to the external file providing this Enum
  - `:icon_tileset_uid` - Tileset UID if provided
  - `:identifier` - User defined unique identifier
  - `:tags` - An array of user-defined tags to organize the Enums
  - `:uid` - Unique Int identifier
  - `:values` - All possible enum values, with their optional Tile infos.
  """

  @enforce_keys [:identifier, :tags, :uid, :values]
  defstruct [
    :external_file_checksum,
    :external_rel_path,
    :icon_tileset_uid,
    :identifier,
    :tags,
    :uid,
    :values
  ]

  @type t :: %__MODULE__{
          external_file_checksum: nil | String.t() | nil,
          external_rel_path: nil | String.t() | nil,
          icon_tileset_uid: integer() | nil | nil,
          identifier: String.t(),
          tags: [String.t()],
          uid: integer(),
          values: [Ldtk.EnumValueDefinition.t()]
        }

  def from_map(m) do
    %Ldtk.EnumDefinition{
      external_file_checksum: m["externalFileChecksum"],
      external_rel_path: m["externalRelPath"],
      icon_tileset_uid: m["iconTilesetUid"],
      identifier: m["identifier"],
      tags: m["tags"],
      uid: m["uid"],
      values: Enum.map(m["values"], &Ldtk.EnumValueDefinition.from_map/1)
    }
  end

  def from_json(json) do
    json
    |> Jason.decode!()
    |> from_map()
  end

  def to_map(struct) do
    %{
      "externalFileChecksum" => struct.external_file_checksum,
      "externalRelPath" => struct.external_rel_path,
      "iconTilesetUid" => struct.icon_tileset_uid,
      "identifier" => struct.identifier,
      "tags" => struct.tags,
      "uid" => struct.uid,
      "values" => struct.values && Enum.map(struct.values, &Ldtk.EnumValueDefinition.to_map/1)
    }
  end

  def to_json(struct) do
    struct
    |> to_map()
    |> Jason.encode!()
  end
end

defmodule Ldtk.Checker do
  @moduledoc """
  Checker mode Possible values: `None`, `Horizontal`, `Vertical`
  """
  @valid_enum_members [
    :Horizontal,
    :None,
    :Vertical
  ]

  def valid_atom?(value), do: value in @valid_enum_members

  def valid_atom_string?(value) do
    try do
      atom = String.to_existing_atom(value)
      atom in @valid_enum_members
    rescue
      ArgumentError -> false
    end
  end

  def encode(value) do
    if valid_atom?(value) do
      Atom.to_string(value)
    else
      {:error, "Unexpected value when encoding atom: #{inspect(value)}"}
    end
  end

  def decode(value) do
    if valid_atom_string?(value) do
      String.to_existing_atom(value)
    else
      {:error, "Unexpected value when decoding atom: #{inspect(value)}"}
    end
  end

  def from_json(json) do
    json
    |> Jason.decode!()
    |> decode()
  end

  def to_json(data) do
    data
    |> encode()
    |> Jason.encode!()
  end
end

defmodule Ldtk.TileMode do
  @moduledoc """
  Defines how tileIds array is used Possible values: `Single`, `Stamp`
  """
  @valid_enum_members [
    :Single,
    :Stamp
  ]

  def valid_atom?(value), do: value in @valid_enum_members

  def valid_atom_string?(value) do
    try do
      atom = String.to_existing_atom(value)
      atom in @valid_enum_members
    rescue
      ArgumentError -> false
    end
  end

  def encode(value) do
    if valid_atom?(value) do
      Atom.to_string(value)
    else
      {:error, "Unexpected value when encoding atom: #{inspect(value)}"}
    end
  end

  def decode(value) do
    if valid_atom_string?(value) do
      String.to_existing_atom(value)
    else
      {:error, "Unexpected value when decoding atom: #{inspect(value)}"}
    end
  end

  def from_json(json) do
    json
    |> Jason.decode!()
    |> decode()
  end

  def to_json(data) do
    data
    |> encode()
    |> Jason.encode!()
  end
end

defmodule Ldtk.AutoLayerRuleDefinition do
  @moduledoc """
  This complex section isn't meant to be used by game devs at all, as these rules are
  completely resolved internally by the editor before any saving. You should just ignore
  this part.
  - `:active` - If FALSE, the rule effect isn't applied, and no tiles are generated.
  - `:break_on_match` - When TRUE, the rule will prevent other rules to be applied in the same cell if it matches(TRUE by default).
  - `:chance` - Chances for this rule to be applied (0 to 1)
  - `:checker` - Checker mode Possible values: `None`, `Horizontal`, `Vertical`
  - `:flip_x` - If TRUE, allow rule to be matched by flipping its pattern horizontally
  - `:flip_y` - If TRUE, allow rule to be matched by flipping its pattern vertically
  - `:invalidated` - If TRUE, then the rule should be re-evaluated by the editor at one point
  - `:out_of_bounds_value` - Default IntGrid value when checking cells outside of level bounds
  - `:pattern` - Rule pattern (size x size)
  - `:perlin_active` - If TRUE, enable Perlin filtering to only apply rule on specific random area
  - `:pivot_x` - X pivot of a tile stamp (0-1)
  - `:pivot_y` - Y pivot of a tile stamp (0-1)
  - `:size` - Pattern width & height. Should only be 1,3,5 or 7.
  - `:tile_ids` - **WARNING**: this deprecated value is no longer exported since version 1.5.0  Replacedby: `tileRectsIds`
  - `:tile_mode` - Defines how tileIds array is used Possible values: `Single`, `Stamp`
  - `:tile_random_x_max` - Max random offset for X tile pos
  - `:tile_random_x_min` - Min random offset for X tile pos
  - `:tile_random_y_max` - Max random offset for Y tile pos
  - `:tile_random_y_min` - Min random offset for Y tile pos
  - `:tile_rects_ids` - Array containing all the possible tile IDs rectangles (picked randomly).
  - `:tile_x_offset` - Tile X offset
  - `:tile_y_offset` - Tile Y offset
  - `:uid` - Unique Int identifier
  - `:x_modulo` - X cell coord modulo
  - `:x_offset` - X cell start offset
  - `:y_modulo` - Y cell coord modulo
  - `:y_offset` - Y cell start offset
  """

  @enforce_keys [
    :active,
    :alpha,
    :break_on_match,
    :chance,
    :checker,
    :flip_x,
    :flip_y,
    :invalidated,
    :pattern,
    :perlin_active,
    :perlin_octaves,
    :perlin_scale,
    :perlin_seed,
    :pivot_x,
    :pivot_y,
    :size,
    :tile_mode,
    :tile_random_x_max,
    :tile_random_x_min,
    :tile_random_y_max,
    :tile_random_y_min,
    :tile_rects_ids,
    :tile_x_offset,
    :tile_y_offset,
    :uid,
    :x_modulo,
    :x_offset,
    :y_modulo,
    :y_offset
  ]
  defstruct [
    :active,
    :alpha,
    :break_on_match,
    :chance,
    :checker,
    :flip_x,
    :flip_y,
    :invalidated,
    :out_of_bounds_value,
    :pattern,
    :perlin_active,
    :perlin_octaves,
    :perlin_scale,
    :perlin_seed,
    :pivot_x,
    :pivot_y,
    :size,
    :tile_ids,
    :tile_mode,
    :tile_random_x_max,
    :tile_random_x_min,
    :tile_random_y_max,
    :tile_random_y_min,
    :tile_rects_ids,
    :tile_x_offset,
    :tile_y_offset,
    :uid,
    :x_modulo,
    :x_offset,
    :y_modulo,
    :y_offset
  ]

  @type t :: %__MODULE__{
          active: boolean(),
          alpha: float(),
          break_on_match: boolean(),
          chance: float(),
          checker: Ldtk.Checker.t(),
          flip_x: boolean(),
          flip_y: boolean(),
          invalidated: boolean(),
          out_of_bounds_value: integer() | nil | nil,
          pattern: [integer()],
          perlin_active: boolean(),
          perlin_octaves: float(),
          perlin_scale: float(),
          perlin_seed: float(),
          pivot_x: float(),
          pivot_y: float(),
          size: integer(),
          tile_ids: [integer()] | nil | nil,
          tile_mode: Ldtk.TileMode.t(),
          tile_random_x_max: integer(),
          tile_random_x_min: integer(),
          tile_random_y_max: integer(),
          tile_random_y_min: integer(),
          tile_rects_ids: [[integer()]],
          tile_x_offset: integer(),
          tile_y_offset: integer(),
          uid: integer(),
          x_modulo: integer(),
          x_offset: integer(),
          y_modulo: integer(),
          y_offset: integer()
        }

  def from_map(m) do
    %Ldtk.AutoLayerRuleDefinition{
      active: m["active"],
      alpha: m["alpha"],
      break_on_match: m["breakOnMatch"],
      chance: m["chance"],
      checker: Ldtk.Checker.decode(m["checker"]),
      flip_x: m["flipX"],
      flip_y: m["flipY"],
      invalidated: m["invalidated"],
      out_of_bounds_value: m["outOfBoundsValue"],
      pattern: m["pattern"],
      perlin_active: m["perlinActive"],
      perlin_octaves: m["perlinOctaves"],
      perlin_scale: m["perlinScale"],
      perlin_seed: m["perlinSeed"],
      pivot_x: m["pivotX"],
      pivot_y: m["pivotY"],
      size: m["size"],
      tile_ids: m["tileIds"],
      tile_mode: Ldtk.TileMode.decode(m["tileMode"]),
      tile_random_x_max: m["tileRandomXMax"],
      tile_random_x_min: m["tileRandomXMin"],
      tile_random_y_max: m["tileRandomYMax"],
      tile_random_y_min: m["tileRandomYMin"],
      tile_rects_ids: m["tileRectsIds"],
      tile_x_offset: m["tileXOffset"],
      tile_y_offset: m["tileYOffset"],
      uid: m["uid"],
      x_modulo: m["xModulo"],
      x_offset: m["xOffset"],
      y_modulo: m["yModulo"],
      y_offset: m["yOffset"]
    }
  end

  def from_json(json) do
    json
    |> Jason.decode!()
    |> from_map()
  end

  def to_map(struct) do
    %{
      "active" => struct.active,
      "alpha" => struct.alpha,
      "breakOnMatch" => struct.break_on_match,
      "chance" => struct.chance,
      "checker" => Ldtk.Checker.encode(struct.checker),
      "flipX" => struct.flip_x,
      "flipY" => struct.flip_y,
      "invalidated" => struct.invalidated,
      "outOfBoundsValue" => struct.out_of_bounds_value,
      "pattern" => struct.pattern,
      "perlinActive" => struct.perlin_active,
      "perlinOctaves" => struct.perlin_octaves,
      "perlinScale" => struct.perlin_scale,
      "perlinSeed" => struct.perlin_seed,
      "pivotX" => struct.pivot_x,
      "pivotY" => struct.pivot_y,
      "size" => struct.size,
      "tileIds" => struct.tile_ids,
      "tileMode" => Ldtk.TileMode.encode(struct.tile_mode),
      "tileRandomXMax" => struct.tile_random_x_max,
      "tileRandomXMin" => struct.tile_random_x_min,
      "tileRandomYMax" => struct.tile_random_y_max,
      "tileRandomYMin" => struct.tile_random_y_min,
      "tileRectsIds" => struct.tile_rects_ids,
      "tileXOffset" => struct.tile_x_offset,
      "tileYOffset" => struct.tile_y_offset,
      "uid" => struct.uid,
      "xModulo" => struct.x_modulo,
      "xOffset" => struct.x_offset,
      "yModulo" => struct.y_modulo,
      "yOffset" => struct.y_offset
    }
  end

  def to_json(struct) do
    struct
    |> to_map()
    |> Jason.encode!()
  end
end

defmodule Ldtk.AutoLayerRuleGroup do
  @moduledoc """
  - `:collapsed` - *This field was removed in 1.0.0 and should no longer be used.*
  """

  @enforce_keys [
    :active,
    :biome_requirement_mode,
    :is_optional,
    :name,
    :required_biome_values,
    :rules,
    :uid,
    :uses_wizard
  ]
  defstruct [
    :active,
    :biome_requirement_mode,
    :collapsed,
    :color,
    :icon,
    :is_optional,
    :name,
    :required_biome_values,
    :rules,
    :uid,
    :uses_wizard
  ]

  @type t :: %__MODULE__{
          active: boolean(),
          biome_requirement_mode: integer(),
          collapsed: boolean() | nil | nil,
          color: nil | String.t() | nil,
          icon: Ldtk.TilesetRectangle.t() | nil | nil,
          is_optional: boolean(),
          name: String.t(),
          required_biome_values: [String.t()],
          rules: [Ldtk.AutoLayerRuleDefinition.t()],
          uid: integer(),
          uses_wizard: boolean()
        }

  def from_map(m) do
    %Ldtk.AutoLayerRuleGroup{
      active: m["active"],
      biome_requirement_mode: m["biomeRequirementMode"],
      collapsed: m["collapsed"],
      color: m["color"],
      icon: m["icon"] && Ldtk.TilesetRectangle.from_map(m["icon"]),
      is_optional: m["isOptional"],
      name: m["name"],
      required_biome_values: m["requiredBiomeValues"],
      rules: Enum.map(m["rules"], &Ldtk.AutoLayerRuleDefinition.from_map/1),
      uid: m["uid"],
      uses_wizard: m["usesWizard"]
    }
  end

  def from_json(json) do
    json
    |> Jason.decode!()
    |> from_map()
  end

  def to_map(struct) do
    %{
      "active" => struct.active,
      "biomeRequirementMode" => struct.biome_requirement_mode,
      "collapsed" => struct.collapsed,
      "color" => struct.color,
      "icon" => struct.icon && Ldtk.TilesetRectangle.to_map(struct.icon),
      "isOptional" => struct.is_optional,
      "name" => struct.name,
      "requiredBiomeValues" => struct.required_biome_values,
      "rules" => struct.rules && Enum.map(struct.rules, &Ldtk.AutoLayerRuleDefinition.to_map/1),
      "uid" => struct.uid,
      "usesWizard" => struct.uses_wizard
    }
  end

  def to_json(struct) do
    struct
    |> to_map()
    |> Jason.encode!()
  end
end

defmodule Ldtk.IntGridValueDefinition do
  @moduledoc """
  IntGrid value definition
  - `:group_uid` - Parent group identifier (0 if none)
  - `:identifier` - User defined unique identifier
  - `:value` - The IntGrid value itself
  """

  @enforce_keys [:color, :group_uid, :value]
  defstruct [:color, :group_uid, :identifier, :tile, :value]

  @type t :: %__MODULE__{
          color: String.t(),
          group_uid: integer(),
          identifier: nil | String.t() | nil,
          tile: Ldtk.TilesetRectangle.t() | nil | nil,
          value: integer()
        }

  def from_map(m) do
    %Ldtk.IntGridValueDefinition{
      color: m["color"],
      group_uid: m["groupUid"],
      identifier: m["identifier"],
      tile: m["tile"] && Ldtk.TilesetRectangle.from_map(m["tile"]),
      value: m["value"]
    }
  end

  def from_json(json) do
    json
    |> Jason.decode!()
    |> from_map()
  end

  def to_map(struct) do
    %{
      "color" => struct.color,
      "groupUid" => struct.group_uid,
      "identifier" => struct.identifier,
      "tile" => struct.tile && Ldtk.TilesetRectangle.to_map(struct.tile),
      "value" => struct.value
    }
  end

  def to_json(struct) do
    struct
    |> to_map()
    |> Jason.encode!()
  end
end

defmodule Ldtk.IntGridValueGroupDefinition do
  @moduledoc """
  IntGrid value group definition
  - `:color` - User defined color
  - `:identifier` - User defined string identifier
  - `:uid` - Group unique ID
  """

  @enforce_keys [:uid]
  defstruct [:color, :identifier, :uid]

  @type t :: %__MODULE__{
          color: nil | String.t() | nil,
          identifier: nil | String.t() | nil,
          uid: integer()
        }

  def from_map(m) do
    %Ldtk.IntGridValueGroupDefinition{
      color: m["color"],
      identifier: m["identifier"],
      uid: m["uid"]
    }
  end

  def from_json(json) do
    json
    |> Jason.decode!()
    |> from_map()
  end

  def to_map(struct) do
    %{
      "color" => struct.color,
      "identifier" => struct.identifier,
      "uid" => struct.uid
    }
  end

  def to_json(struct) do
    struct
    |> to_map()
    |> Jason.encode!()
  end
end

defmodule Ldtk.Type do
  @moduledoc """
  Type of the layer as Haxe Enum Possible values: `IntGrid`, `Entities`, `Tiles`,
  `AutoLayer`
  """
  @valid_enum_members [
    :AutoLayer,
    :Entities,
    :IntGrid,
    :Tiles
  ]

  def valid_atom?(value), do: value in @valid_enum_members

  def valid_atom_string?(value) do
    try do
      atom = String.to_existing_atom(value)
      atom in @valid_enum_members
    rescue
      ArgumentError -> false
    end
  end

  def encode(value) do
    if valid_atom?(value) do
      Atom.to_string(value)
    else
      {:error, "Unexpected value when encoding atom: #{inspect(value)}"}
    end
  end

  def decode(value) do
    if valid_atom_string?(value) do
      String.to_existing_atom(value)
    else
      {:error, "Unexpected value when decoding atom: #{inspect(value)}"}
    end
  end

  def from_json(json) do
    json
    |> Jason.decode!()
    |> decode()
  end

  def to_json(data) do
    data
    |> encode()
    |> Jason.encode!()
  end
end

defmodule Ldtk.LayerDefinition do
  @moduledoc """
  - `:type` - Type of the layer (*IntGrid, Entities, Tiles or AutoLayer*)
  - `:auto_rule_groups` - Contains all the auto-layer rule definitions.
  - `:auto_tileset_def_uid` - **WARNING**: this deprecated value is no longer exported since version 1.2.0  Replacedby: `tilesetDefUid`
  - `:can_select_when_inactive` - Allow editor selections when the layer is not currently active.
  - `:display_opacity` - Opacity of the layer (0 to 1.0)
  - `:doc` - User defined documentation for this element to provide help/tips to level designers.
  - `:excluded_tags` - An array of tags to forbid some Entities in this layer
  - `:grid_size` - Width and height of the grid in pixels
  - `:guide_grid_hei` - Height of the optional "guide" grid in pixels
  - `:guide_grid_wid` - Width of the optional "guide" grid in pixels
  - `:hide_in_list` - Hide the layer from the list on the side of the editor view.
  - `:identifier` - User defined unique identifier
  - `:inactive_opacity` - Alpha of this layer when it is not the active one.
  - `:int_grid_values` - An array that defines extra optional info for each IntGrid value.<br/>  WARNING: thearray order is not related to actual IntGrid values! As user can re-order IntGrid valuesfreely, you may value "2" before value "1" in this array.
  - `:int_grid_values_groups` - Group informations for IntGrid values
  - `:parallax_factor_x` - Parallax horizontal factor (from -1 to 1, defaults to 0) which affects the scrollingspeed of this layer, creating a fake 3D (parallax) effect.
  - `:parallax_factor_y` - Parallax vertical factor (from -1 to 1, defaults to 0) which affects the scrolling speedof this layer, creating a fake 3D (parallax) effect.
  - `:parallax_scaling` - If true (default), a layer with a parallax factor will also be scaled up/down accordingly.
  - `:px_offset_x` - X offset of the layer, in pixels (IMPORTANT: this should be added to the `LayerInstance`optional offset)
  - `:px_offset_y` - Y offset of the layer, in pixels (IMPORTANT: this should be added to the `LayerInstance`optional offset)
  - `:render_in_world_view` - If TRUE, the content of this layer will be used when rendering levels in a simplified wayfor the world view
  - `:required_tags` - An array of tags to filter Entities that can be added to this layer
  - `:tile_pivot_x` - If the tiles are smaller or larger than the layer grid, the pivot value will be used toposition the tile relatively its grid cell.
  - `:tile_pivot_y` - If the tiles are smaller or larger than the layer grid, the pivot value will be used toposition the tile relatively its grid cell.
  - `:tileset_def_uid` - Reference to the default Tileset UID being used by this layer definition.<br/>**WARNING**: some layer *instances* might use a different tileset. So most of the time,you should probably use the `__tilesetDefUid` value found in layer instances.<br/>  Note:since version 1.0.0, the old `autoTilesetDefUid` was removed and merged into this value.
  - `:layer_definition_type` - Type of the layer as Haxe Enum Possible values: `IntGrid`, `Entities`, `Tiles`,`AutoLayer`
  - `:ui_color` - User defined color for the UI
  - `:uid` - Unique Int identifier
  - `:ui_filter_tags` - Display tags
  - `:use_async_render` - Asynchronous rendering option for large/complex layers
  """

  @enforce_keys [
    :type,
    :auto_rule_groups,
    :can_select_when_inactive,
    :display_opacity,
    :excluded_tags,
    :grid_size,
    :guide_grid_hei,
    :guide_grid_wid,
    :hide_fields_when_inactive,
    :hide_in_list,
    :identifier,
    :inactive_opacity,
    :int_grid_values,
    :int_grid_values_groups,
    :parallax_factor_x,
    :parallax_factor_y,
    :parallax_scaling,
    :px_offset_x,
    :px_offset_y,
    :render_in_world_view,
    :required_tags,
    :tile_pivot_x,
    :tile_pivot_y,
    :layer_definition_type,
    :uid,
    :ui_filter_tags,
    :use_async_render
  ]
  defstruct [
    :type,
    :auto_rule_groups,
    :auto_source_layer_def_uid,
    :auto_tileset_def_uid,
    :auto_tiles_killed_by_other_layer_uid,
    :biome_field_uid,
    :can_select_when_inactive,
    :display_opacity,
    :doc,
    :excluded_tags,
    :grid_size,
    :guide_grid_hei,
    :guide_grid_wid,
    :hide_fields_when_inactive,
    :hide_in_list,
    :identifier,
    :inactive_opacity,
    :int_grid_values,
    :int_grid_values_groups,
    :parallax_factor_x,
    :parallax_factor_y,
    :parallax_scaling,
    :px_offset_x,
    :px_offset_y,
    :render_in_world_view,
    :required_tags,
    :tile_pivot_x,
    :tile_pivot_y,
    :tileset_def_uid,
    :layer_definition_type,
    :ui_color,
    :uid,
    :ui_filter_tags,
    :use_async_render
  ]

  @type t :: %__MODULE__{
          type: String.t(),
          auto_rule_groups: [Ldtk.AutoLayerRuleGroup.t()],
          auto_source_layer_def_uid: integer() | nil | nil,
          auto_tileset_def_uid: integer() | nil | nil,
          auto_tiles_killed_by_other_layer_uid: integer() | nil | nil,
          biome_field_uid: integer() | nil | nil,
          can_select_when_inactive: boolean(),
          display_opacity: float(),
          doc: nil | String.t() | nil,
          excluded_tags: [String.t()],
          grid_size: integer(),
          guide_grid_hei: integer(),
          guide_grid_wid: integer(),
          hide_fields_when_inactive: boolean(),
          hide_in_list: boolean(),
          identifier: String.t(),
          inactive_opacity: float(),
          int_grid_values: [Ldtk.IntGridValueDefinition.t()],
          int_grid_values_groups: [Ldtk.IntGridValueGroupDefinition.t()],
          parallax_factor_x: float(),
          parallax_factor_y: float(),
          parallax_scaling: boolean(),
          px_offset_x: integer(),
          px_offset_y: integer(),
          render_in_world_view: boolean(),
          required_tags: [String.t()],
          tile_pivot_x: float(),
          tile_pivot_y: float(),
          tileset_def_uid: integer() | nil | nil,
          layer_definition_type: Ldtk.Type.t(),
          ui_color: nil | String.t() | nil,
          uid: integer(),
          ui_filter_tags: [String.t()],
          use_async_render: boolean()
        }

  def from_map(m) do
    %Ldtk.LayerDefinition{
      type: m["__type"],
      auto_rule_groups: Enum.map(m["autoRuleGroups"], &Ldtk.AutoLayerRuleGroup.from_map/1),
      auto_source_layer_def_uid: m["autoSourceLayerDefUid"],
      auto_tileset_def_uid: m["autoTilesetDefUid"],
      auto_tiles_killed_by_other_layer_uid: m["autoTilesKilledByOtherLayerUid"],
      biome_field_uid: m["biomeFieldUid"],
      can_select_when_inactive: m["canSelectWhenInactive"],
      display_opacity: m["displayOpacity"],
      doc: m["doc"],
      excluded_tags: m["excludedTags"],
      grid_size: m["gridSize"],
      guide_grid_hei: m["guideGridHei"],
      guide_grid_wid: m["guideGridWid"],
      hide_fields_when_inactive: m["hideFieldsWhenInactive"],
      hide_in_list: m["hideInList"],
      identifier: m["identifier"],
      inactive_opacity: m["inactiveOpacity"],
      int_grid_values: Enum.map(m["intGridValues"], &Ldtk.IntGridValueDefinition.from_map/1),
      int_grid_values_groups:
        Enum.map(m["intGridValuesGroups"], &Ldtk.IntGridValueGroupDefinition.from_map/1),
      parallax_factor_x: m["parallaxFactorX"],
      parallax_factor_y: m["parallaxFactorY"],
      parallax_scaling: m["parallaxScaling"],
      px_offset_x: m["pxOffsetX"],
      px_offset_y: m["pxOffsetY"],
      render_in_world_view: m["renderInWorldView"],
      required_tags: m["requiredTags"],
      tile_pivot_x: m["tilePivotX"],
      tile_pivot_y: m["tilePivotY"],
      tileset_def_uid: m["tilesetDefUid"],
      layer_definition_type: Ldtk.Type.decode(m["type"]),
      ui_color: m["uiColor"],
      uid: m["uid"],
      ui_filter_tags: m["uiFilterTags"],
      use_async_render: m["useAsyncRender"]
    }
  end

  def from_json(json) do
    json
    |> Jason.decode!()
    |> from_map()
  end

  def to_map(struct) do
    %{
      "__type" => struct.type,
      "autoRuleGroups" =>
        struct.auto_rule_groups &&
          Enum.map(struct.auto_rule_groups, &Ldtk.AutoLayerRuleGroup.to_map/1),
      "autoSourceLayerDefUid" => struct.auto_source_layer_def_uid,
      "autoTilesetDefUid" => struct.auto_tileset_def_uid,
      "autoTilesKilledByOtherLayerUid" => struct.auto_tiles_killed_by_other_layer_uid,
      "biomeFieldUid" => struct.biome_field_uid,
      "canSelectWhenInactive" => struct.can_select_when_inactive,
      "displayOpacity" => struct.display_opacity,
      "doc" => struct.doc,
      "excludedTags" => struct.excluded_tags,
      "gridSize" => struct.grid_size,
      "guideGridHei" => struct.guide_grid_hei,
      "guideGridWid" => struct.guide_grid_wid,
      "hideFieldsWhenInactive" => struct.hide_fields_when_inactive,
      "hideInList" => struct.hide_in_list,
      "identifier" => struct.identifier,
      "inactiveOpacity" => struct.inactive_opacity,
      "intGridValues" =>
        struct.int_grid_values &&
          Enum.map(struct.int_grid_values, &Ldtk.IntGridValueDefinition.to_map/1),
      "intGridValuesGroups" =>
        struct.int_grid_values_groups &&
          Enum.map(struct.int_grid_values_groups, &Ldtk.IntGridValueGroupDefinition.to_map/1),
      "parallaxFactorX" => struct.parallax_factor_x,
      "parallaxFactorY" => struct.parallax_factor_y,
      "parallaxScaling" => struct.parallax_scaling,
      "pxOffsetX" => struct.px_offset_x,
      "pxOffsetY" => struct.px_offset_y,
      "renderInWorldView" => struct.render_in_world_view,
      "requiredTags" => struct.required_tags,
      "tilePivotX" => struct.tile_pivot_x,
      "tilePivotY" => struct.tile_pivot_y,
      "tilesetDefUid" => struct.tileset_def_uid,
      "type" => Ldtk.Type.encode(struct.layer_definition_type),
      "uiColor" => struct.ui_color,
      "uid" => struct.uid,
      "uiFilterTags" => struct.ui_filter_tags,
      "useAsyncRender" => struct.use_async_render
    }
  end

  def to_json(struct) do
    struct
    |> to_map()
    |> Jason.encode!()
  end
end

defmodule Ldtk.TileCustomMetadata do
  @moduledoc """
  In a tileset definition, user defined meta-data of a tile.
  """

  @enforce_keys [:data, :tile_id]
  defstruct [:data, :tile_id]

  @type t :: %__MODULE__{
          data: String.t(),
          tile_id: integer()
        }

  def from_map(m) do
    %Ldtk.TileCustomMetadata{
      data: m["data"],
      tile_id: m["tileId"]
    }
  end

  def from_json(json) do
    json
    |> Jason.decode!()
    |> from_map()
  end

  def to_map(struct) do
    %{
      "data" => struct.data,
      "tileId" => struct.tile_id
    }
  end

  def to_json(struct) do
    struct
    |> to_map()
    |> Jason.encode!()
  end
end

defmodule Ldtk.EmbedAtlas do
  @valid_enum_members [
    :LdtkIcons
  ]

  def valid_atom?(value), do: value in @valid_enum_members

  def valid_atom_string?(value) do
    try do
      atom = String.to_existing_atom(value)
      atom in @valid_enum_members
    rescue
      ArgumentError -> false
    end
  end

  def encode(value) do
    if valid_atom?(value) do
      Atom.to_string(value)
    else
      {:error, "Unexpected value when encoding atom: #{inspect(value)}"}
    end
  end

  def decode(value) do
    if valid_atom_string?(value) do
      String.to_existing_atom(value)
    else
      {:error, "Unexpected value when decoding atom: #{inspect(value)}"}
    end
  end

  def from_json(json) do
    json
    |> Jason.decode!()
    |> decode()
  end

  def to_json(data) do
    data
    |> encode()
    |> Jason.encode!()
  end
end

defmodule Ldtk.EnumTagValue do
  @moduledoc """
  In a tileset definition, enum based tag infos
  """

  @enforce_keys [:enum_value_id, :tile_ids]
  defstruct [:enum_value_id, :tile_ids]

  @type t :: %__MODULE__{
          enum_value_id: String.t(),
          tile_ids: [integer()]
        }

  def from_map(m) do
    %Ldtk.EnumTagValue{
      enum_value_id: m["enumValueId"],
      tile_ids: m["tileIds"]
    }
  end

  def from_json(json) do
    json
    |> Jason.decode!()
    |> from_map()
  end

  def to_map(struct) do
    %{
      "enumValueId" => struct.enum_value_id,
      "tileIds" => struct.tile_ids
    }
  end

  def to_json(struct) do
    struct
    |> to_map()
    |> Jason.encode!()
  end
end

defmodule Ldtk.TilesetDefinition do
  @moduledoc """
  The `Tileset` definition is the most important part among project definitions. It
  contains some extra informations about each integrated tileset. If you only had to parse
  one definition section, that would be the one.
  - `:c_hei` - Grid-based height
  - `:c_wid` - Grid-based width
  - `:cached_pixel_data` - The following data is used internally for various optimizations. It's always synced withsource image changes.
  - `:custom_data` - An array of custom tile metadata
  - `:embed_atlas` - If this value is set, then it means that this atlas uses an internal LDtk atlas imageinstead of a loaded one. Possible values: &lt;`null`&gt;, `LdtkIcons`
  - `:enum_tags` - Tileset tags using Enum values specified by `tagsSourceEnumId`. This array contains 1element per Enum value, which contains an array of all Tile IDs that are tagged with it.
  - `:identifier` - User defined unique identifier
  - `:padding` - Distance in pixels from image borders
  - `:px_hei` - Image height in pixels
  - `:px_wid` - Image width in pixels
  - `:rel_path` - Path to the source file, relative to the current project JSON file<br/>  It can be nullif no image was provided, or when using an embed atlas.
  - `:saved_selections` - Array of group of tiles selections, only meant to be used in the editor
  - `:spacing` - Space in pixels between all tiles
  - `:tags` - An array of user-defined tags to organize the Tilesets
  - `:tags_source_enum_uid` - Optional Enum definition UID used for this tileset meta-data
  - `:uid` - Unique Intidentifier
  """

  @enforce_keys [
    :c_hei,
    :c_wid,
    :custom_data,
    :enum_tags,
    :identifier,
    :padding,
    :px_hei,
    :px_wid,
    :saved_selections,
    :spacing,
    :tags,
    :tile_grid_size,
    :uid
  ]
  defstruct [
    :c_hei,
    :c_wid,
    :cached_pixel_data,
    :custom_data,
    :embed_atlas,
    :enum_tags,
    :identifier,
    :padding,
    :px_hei,
    :px_wid,
    :rel_path,
    :saved_selections,
    :spacing,
    :tags,
    :tags_source_enum_uid,
    :tile_grid_size,
    :uid
  ]

  @type t :: %__MODULE__{
          c_hei: integer(),
          c_wid: integer(),
          cached_pixel_data: %{String.t() => any()} | nil | nil,
          custom_data: [Ldtk.TileCustomMetadata.t()],
          embed_atlas: Ldtk.EmbedAtlas.t() | nil | nil,
          enum_tags: [Ldtk.EnumTagValue.t()],
          identifier: String.t(),
          padding: integer(),
          px_hei: integer(),
          px_wid: integer(),
          rel_path: nil | String.t() | nil,
          saved_selections: [%{String.t() => any()}],
          spacing: integer(),
          tags: [String.t()],
          tags_source_enum_uid: integer() | nil | nil,
          tile_grid_size: integer(),
          uid: integer()
        }

  def from_map(m) do
    %Ldtk.TilesetDefinition{
      c_hei: m["__cHei"],
      c_wid: m["__cWid"],
      cached_pixel_data: m["cachedPixelData"],
      custom_data: Enum.map(m["customData"], &Ldtk.TileCustomMetadata.from_map/1),
      embed_atlas: m["embedAtlas"] && Ldtk.EmbedAtlas.decode(m["embedAtlas"]),
      enum_tags: Enum.map(m["enumTags"], &Ldtk.EnumTagValue.from_map/1),
      identifier: m["identifier"],
      padding: m["padding"],
      px_hei: m["pxHei"],
      px_wid: m["pxWid"],
      rel_path: m["relPath"],
      saved_selections: m["savedSelections"],
      spacing: m["spacing"],
      tags: m["tags"],
      tags_source_enum_uid: m["tagsSourceEnumUid"],
      tile_grid_size: m["tileGridSize"],
      uid: m["uid"]
    }
  end

  def from_json(json) do
    json
    |> Jason.decode!()
    |> from_map()
  end

  def to_map(struct) do
    %{
      "__cHei" => struct.c_hei,
      "__cWid" => struct.c_wid,
      "cachedPixelData" => struct.cached_pixel_data,
      "customData" =>
        struct.custom_data && Enum.map(struct.custom_data, &Ldtk.TileCustomMetadata.to_map/1),
      "embedAtlas" => struct.embed_atlas && Ldtk.EmbedAtlas.encode(struct.embed_atlas),
      "enumTags" => struct.enum_tags && Enum.map(struct.enum_tags, &Ldtk.EnumTagValue.to_map/1),
      "identifier" => struct.identifier,
      "padding" => struct.padding,
      "pxHei" => struct.px_hei,
      "pxWid" => struct.px_wid,
      "relPath" => struct.rel_path,
      "savedSelections" => struct.saved_selections,
      "spacing" => struct.spacing,
      "tags" => struct.tags,
      "tagsSourceEnumUid" => struct.tags_source_enum_uid,
      "tileGridSize" => struct.tile_grid_size,
      "uid" => struct.uid
    }
  end

  def to_json(struct) do
    struct
    |> to_map()
    |> Jason.encode!()
  end
end

defmodule Ldtk.Definitions do
  @moduledoc """
  If you're writing your own LDtk importer, you should probably just ignore *most* stuff in
  the `defs` section, as it contains data that are mostly important to the editor. To keep
  you away from the `defs` section and avoid some unnecessary JSON parsing, important data
  from definitions is often duplicated in fields prefixed with a double underscore (eg.
  `__identifier` or `__type`).  The 2 only definition types you might need here are
  **Tilesets** and **Enums**.

  A structure containing all the definitions of this project
  - `:entities` - All entities definitions, including their custom fields
  - `:enums` - All internal enums
  - `:external_enums` - Note: external enums are exactly the same as `enums`, except they have a `relPath` topoint to an external source file.
  - `:layers` - All layer definitions
  - `:level_fields` - All custom fields available to all levels.
  - `:tilesets` - All tilesets
  """

  @enforce_keys [:entities, :enums, :external_enums, :layers, :level_fields, :tilesets]
  defstruct [:entities, :enums, :external_enums, :layers, :level_fields, :tilesets]

  @type t :: %__MODULE__{
          entities: [Ldtk.EntityDefinition.t()],
          enums: [Ldtk.EnumDefinition.t()],
          external_enums: [Ldtk.EnumDefinition.t()],
          layers: [Ldtk.LayerDefinition.t()],
          level_fields: [Ldtk.FieldDefinition.t()],
          tilesets: [Ldtk.TilesetDefinition.t()]
        }

  def from_map(m) do
    %Ldtk.Definitions{
      entities: Enum.map(m["entities"], &Ldtk.EntityDefinition.from_map/1),
      enums: Enum.map(m["enums"], &Ldtk.EnumDefinition.from_map/1),
      external_enums: Enum.map(m["externalEnums"], &Ldtk.EnumDefinition.from_map/1),
      layers: Enum.map(m["layers"], &Ldtk.LayerDefinition.from_map/1),
      level_fields: Enum.map(m["levelFields"], &Ldtk.FieldDefinition.from_map/1),
      tilesets: Enum.map(m["tilesets"], &Ldtk.TilesetDefinition.from_map/1)
    }
  end

  def from_json(json) do
    json
    |> Jason.decode!()
    |> from_map()
  end

  def to_map(struct) do
    %{
      "entities" => struct.entities && Enum.map(struct.entities, &Ldtk.EntityDefinition.to_map/1),
      "enums" => struct.enums && Enum.map(struct.enums, &Ldtk.EnumDefinition.to_map/1),
      "externalEnums" =>
        struct.external_enums && Enum.map(struct.external_enums, &Ldtk.EnumDefinition.to_map/1),
      "layers" => struct.layers && Enum.map(struct.layers, &Ldtk.LayerDefinition.to_map/1),
      "levelFields" =>
        struct.level_fields && Enum.map(struct.level_fields, &Ldtk.FieldDefinition.to_map/1),
      "tilesets" => struct.tilesets && Enum.map(struct.tilesets, &Ldtk.TilesetDefinition.to_map/1)
    }
  end

  def to_json(struct) do
    struct
    |> to_map()
    |> Jason.encode!()
  end
end

defmodule Ldtk.Flag do
  @valid_enum_members [
    :DiscardPreCsvIntGrid,
    :ExportOldTableOfContentData,
    :ExportPreCsvIntGridFormat,
    :IgnoreBackupSuggest,
    :MultiWorlds,
    :PrependIndexToLevelFileNames,
    :UseMultilinesType
  ]

  def valid_atom?(value), do: value in @valid_enum_members

  def valid_atom_string?(value) do
    try do
      atom = String.to_existing_atom(value)
      atom in @valid_enum_members
    rescue
      ArgumentError -> false
    end
  end

  def encode(value) do
    if valid_atom?(value) do
      Atom.to_string(value)
    else
      {:error, "Unexpected value when encoding atom: #{inspect(value)}"}
    end
  end

  def decode(value) do
    if valid_atom_string?(value) do
      String.to_existing_atom(value)
    else
      {:error, "Unexpected value when decoding atom: #{inspect(value)}"}
    end
  end

  def from_json(json) do
    json
    |> Jason.decode!()
    |> decode()
  end

  def to_json(data) do
    data
    |> encode()
    |> Jason.encode!()
  end
end

defmodule Ldtk.FieldInstance do
  @moduledoc """
  - `:identifier` - Field definition identifier
  - `:tile` - Optional TilesetRect used to display this field (this can be the field own Tile, or someother Tile guessed from the value, like an Enum).
  - `:type` - Type of the field, such as `Int`, `Float`, `String`, `Enum(my_enum_name)`, `Bool`,etc.<br/>  NOTE: if you enable the advanced option **Use Multilines type**, you will have"*Multilines*" instead of "*String*" when relevant.
  - `:value` - Actual value of the field instance. The value type varies, depending on `__type`:<br/>- For **classic types** (ie. Integer, Float, Boolean, String, Text and FilePath), youjust get the actual value with the expected type.<br/>   - For **Color**, the value is anhexadecimal string using "#rrggbb" format.<br/>   - For **Enum**, the value is a Stringrepresenting the selected enum value.<br/>   - For **Point**, the value is a[GridPoint](#ldtk-GridPoint) object.<br/>   - For **Tile**, the value is a[TilesetRect](#ldtk-TilesetRect) object.<br/>   - For **EntityRef**, the value is an[EntityReferenceInfos](#ldtk-EntityReferenceInfos) object.<br/><br/>  If the field is anarray, then this `__value` will also be a JSON array.
  - `:def_uid` - Reference of the **Field definition** UID
  - `:real_editor_values` - Editor internal raw values
  """

  @enforce_keys [:identifier, :type, :value, :def_uid, :real_editor_values]
  defstruct [:identifier, :tile, :type, :value, :def_uid, :real_editor_values]

  @type t :: %__MODULE__{
          identifier: String.t(),
          tile: Ldtk.TilesetRectangle.t() | nil | nil,
          type: String.t(),
          value: any(),
          def_uid: integer(),
          real_editor_values: [any()]
        }

  def from_map(m) do
    %Ldtk.FieldInstance{
      identifier: m["__identifier"],
      tile: m["__tile"] && Ldtk.TilesetRectangle.from_map(m["__tile"]),
      type: m["__type"],
      value: m["__value"],
      def_uid: m["defUid"],
      real_editor_values: m["realEditorValues"]
    }
  end

  def from_json(json) do
    json
    |> Jason.decode!()
    |> from_map()
  end

  def to_map(struct) do
    %{
      "__identifier" => struct.identifier,
      "__tile" => struct.tile && Ldtk.TilesetRectangle.to_map(struct.tile),
      "__type" => struct.type,
      "__value" => struct.value,
      "defUid" => struct.def_uid,
      "realEditorValues" => struct.real_editor_values
    }
  end

  def to_json(struct) do
    struct
    |> to_map()
    |> Jason.encode!()
  end
end

defmodule Ldtk.EntityInstance do
  @moduledoc """
  - `:grid` - Grid-based coordinates (`[x,y]` format)
  - `:identifier` - Entity definition identifier
  - `:pivot` - Pivot coordinates  (`[x,y]` format, values are from 0 to 1) of the Entity
  - `:smart_color` - The entity "smart" color, guessed from either Entity definition, or one its fieldinstances.
  - `:tags` - Array of tags defined in this Entity definition
  - `:tile` - Optional TilesetRect used to display this entity (it could either be the default Entitytile, or some tile provided by a field value, like an Enum).
  - `:world_x` - X world coordinate in pixels. Only available in GridVania or Free world layouts.
  - `:world_y` - Y world coordinate in pixels Only available in GridVania or Free world layouts.
  - `:def_uid` - Reference of the **Entity definition** UID
  - `:field_instances` - An array of all custom fields and their values.
  - `:height` - Entity height in pixels. For non-resizable entities, it will be the same as Entitydefinition.
  - `:iid` - Unique instance identifier
  - `:px` - Pixel coordinates (`[x,y]` format) in current level coordinate space. Don't forgetoptional layer offsets, if they exist!
  - `:width` - Entity width in pixels. For non-resizable entities, it will be the same as Entitydefinition.
  """

  @enforce_keys [
    :grid,
    :identifier,
    :pivot,
    :smart_color,
    :tags,
    :def_uid,
    :field_instances,
    :height,
    :iid,
    :px,
    :width
  ]
  defstruct [
    :grid,
    :identifier,
    :pivot,
    :smart_color,
    :tags,
    :tile,
    :world_x,
    :world_y,
    :def_uid,
    :field_instances,
    :height,
    :iid,
    :px,
    :width
  ]

  @type t :: %__MODULE__{
          grid: [integer()],
          identifier: String.t(),
          pivot: [float()],
          smart_color: String.t(),
          tags: [String.t()],
          tile: Ldtk.TilesetRectangle.t() | nil | nil,
          world_x: integer() | nil | nil,
          world_y: integer() | nil | nil,
          def_uid: integer(),
          field_instances: [Ldtk.FieldInstance.t()],
          height: integer(),
          iid: String.t(),
          px: [integer()],
          width: integer()
        }

  def from_map(m) do
    %Ldtk.EntityInstance{
      grid: m["__grid"],
      identifier: m["__identifier"],
      pivot: m["__pivot"],
      smart_color: m["__smartColor"],
      tags: m["__tags"],
      tile: m["__tile"] && Ldtk.TilesetRectangle.from_map(m["__tile"]),
      world_x: m["__worldX"],
      world_y: m["__worldY"],
      def_uid: m["defUid"],
      field_instances: Enum.map(m["fieldInstances"], &Ldtk.FieldInstance.from_map/1),
      height: m["height"],
      iid: m["iid"],
      px: m["px"],
      width: m["width"]
    }
  end

  def from_json(json) do
    json
    |> Jason.decode!()
    |> from_map()
  end

  def to_map(struct) do
    %{
      "__grid" => struct.grid,
      "__identifier" => struct.identifier,
      "__pivot" => struct.pivot,
      "__smartColor" => struct.smart_color,
      "__tags" => struct.tags,
      "__tile" => struct.tile && Ldtk.TilesetRectangle.to_map(struct.tile),
      "__worldX" => struct.world_x,
      "__worldY" => struct.world_y,
      "defUid" => struct.def_uid,
      "fieldInstances" =>
        struct.field_instances && Enum.map(struct.field_instances, &Ldtk.FieldInstance.to_map/1),
      "height" => struct.height,
      "iid" => struct.iid,
      "px" => struct.px,
      "width" => struct.width
    }
  end

  def to_json(struct) do
    struct
    |> to_map()
    |> Jason.encode!()
  end
end

defmodule Ldtk.ReferenceToAnEntityInstance do
  @moduledoc """
  This object describes the "location" of an Entity instance in the project worlds.

  IID information of this instance
  - `:entity_iid` - IID of the refered EntityInstance
  - `:layer_iid` - IID of the LayerInstance containing the refered EntityInstance
  - `:level_iid` - IID of the Level containing the refered EntityInstance
  - `:world_iid` - IID of the World containing the refered EntityInstance
  """

  @enforce_keys [:entity_iid, :layer_iid, :level_iid, :world_iid]
  defstruct [:entity_iid, :layer_iid, :level_iid, :world_iid]

  @type t :: %__MODULE__{
          entity_iid: String.t(),
          layer_iid: String.t(),
          level_iid: String.t(),
          world_iid: String.t()
        }

  def from_map(m) do
    %Ldtk.ReferenceToAnEntityInstance{
      entity_iid: m["entityIid"],
      layer_iid: m["layerIid"],
      level_iid: m["levelIid"],
      world_iid: m["worldIid"]
    }
  end

  def from_json(json) do
    json
    |> Jason.decode!()
    |> from_map()
  end

  def to_map(struct) do
    %{
      "entityIid" => struct.entity_iid,
      "layerIid" => struct.layer_iid,
      "levelIid" => struct.level_iid,
      "worldIid" => struct.world_iid
    }
  end

  def to_json(struct) do
    struct
    |> to_map()
    |> Jason.encode!()
  end
end

defmodule Ldtk.GridPoint do
  @moduledoc """
  This object is just a grid-based coordinate used in Field values.
  - `:cx` - X grid-based coordinate
  - `:cy` - Y grid-based coordinate
  """

  @enforce_keys [:cx, :cy]
  defstruct [:cx, :cy]

  @type t :: %__MODULE__{
          cx: integer(),
          cy: integer()
        }

  def from_map(m) do
    %Ldtk.GridPoint{
      cx: m["cx"],
      cy: m["cy"]
    }
  end

  def from_json(json) do
    json
    |> Jason.decode!()
    |> from_map()
  end

  def to_map(struct) do
    %{
      "cx" => struct.cx,
      "cy" => struct.cy
    }
  end

  def to_json(struct) do
    struct
    |> to_map()
    |> Jason.encode!()
  end
end

defmodule Ldtk.IntGridValueInstance do
  @moduledoc """
  IntGrid value instance
  - `:coord_id` - Coordinate ID in the layer grid
  - `:v` - IntGrid value
  """

  @enforce_keys [:coord_id, :v]
  defstruct [:coord_id, :v]

  @type t :: %__MODULE__{
          coord_id: integer(),
          v: integer()
        }

  def from_map(m) do
    %Ldtk.IntGridValueInstance{
      coord_id: m["coordId"],
      v: m["v"]
    }
  end

  def from_json(json) do
    json
    |> Jason.decode!()
    |> from_map()
  end

  def to_map(struct) do
    %{
      "coordId" => struct.coord_id,
      "v" => struct.v
    }
  end

  def to_json(struct) do
    struct
    |> to_map()
    |> Jason.encode!()
  end
end

defmodule Ldtk.TileInstance do
  @moduledoc """
  This structure represents a single tile from a given Tileset.
  - `:a` - Alpha/opacity of the tile (0-1, defaults to 1)
  - `:d` - Internal data used by the editor.<br/>  For auto-layer tiles: `[ruleId, coordId]`.<br/>For tile-layer tiles: `[coordId]`.
  - `:f` - "Flip bits", a 2-bits integer to represent the mirror transformations of the tile.<br/>- Bit 0 = X flip<br/>   - Bit 1 = Y flip<br/>   Examples: f=0 (no flip), f=1 (X fliponly), f=2 (Y flip only), f=3 (both flips)
  - `:px` - Pixel coordinates of the tile in the **layer** (`[x,y]` format). Don't forget optionallayer offsets, if they exist!
  - `:src` - Pixel coordinates of the tile in the **tileset** (`[x,y]` format)
  - `:t` - The *Tile ID* in the corresponding tileset.
  """

  @enforce_keys [:a, :d, :f, :px, :src, :t]
  defstruct [:a, :d, :f, :px, :src, :t]

  @type t :: %__MODULE__{
          a: float(),
          d: [integer()],
          f: integer(),
          px: [integer()],
          src: [integer()],
          t: integer()
        }

  def from_map(m) do
    %Ldtk.TileInstance{
      a: m["a"],
      d: m["d"],
      f: m["f"],
      px: m["px"],
      src: m["src"],
      t: m["t"]
    }
  end

  def from_json(json) do
    json
    |> Jason.decode!()
    |> from_map()
  end

  def to_map(struct) do
    %{
      "a" => struct.a,
      "d" => struct.d,
      "f" => struct.f,
      "px" => struct.px,
      "src" => struct.src,
      "t" => struct.t
    }
  end

  def to_json(struct) do
    struct
    |> to_map()
    |> Jason.encode!()
  end
end

defmodule Ldtk.LayerInstance do
  @moduledoc """
  - `:c_hei` - Grid-based height
  - `:c_wid` - Grid-based width
  - `:grid_size` - Grid size
  - `:identifier` - Layer definition identifier
  - `:opacity` - Layer opacity as Float [0-1]
  - `:px_total_offset_x` - Total layer X pixel offset, including both instance and definition offsets.
  - `:px_total_offset_y` - Total layer Y pixel offset, including both instance and definition offsets.
  - `:tileset_def_uid` - The definition UID of corresponding Tileset, if any.
  - `:tileset_rel_path` - The relative path to corresponding Tileset, if any.
  - `:type` - Layer type (possible values: IntGrid, Entities, Tiles or AutoLayer)
  - `:auto_layer_tiles` - An array containing all tiles generated by Auto-layer rules. The array is already sortedin display order (ie. 1st tile is beneath 2nd, which is beneath 3rd etc.).<br/><br/>Note: if multiple tiles are stacked in the same cell as the result of different rules,all tiles behind opaque ones will be discarded.
  - `:iid` - Unique layer instance identifier
  - `:int_grid` - **WARNING**: this deprecated value is no longer exported since version 1.0.0  Replacedby: `intGridCsv`
  - `:int_grid_csv` - A list of all values in the IntGrid layer, stored in CSV format (Comma SeparatedValues).<br/>  Order is from left to right, and top to bottom (ie. first row from left toright, followed by second row, etc).<br/>  `0` means "empty cell" and IntGrid valuesstart at 1.<br/>  The array size is `__cWid` x `__cHei` cells.
  - `:layer_def_uid` - Reference the Layer definition UID
  - `:level_id` - Reference to the UID of the level containing this layer instance
  - `:optional_rules` - An Array containing the UIDs of optional rules that were enabled in this specific layerinstance.
  - `:override_tileset_uid` - This layer can use another tileset by overriding the tileset UID here.
  - `:px_offset_x` - X offset in pixels to render this layer, usually 0 (IMPORTANT: this should be added tothe `LayerDef` optional offset, so you should probably prefer using `__pxTotalOffsetX`which contains the total offset value)
  - `:px_offset_y` - Y offset in pixels to render this layer, usually 0 (IMPORTANT: this should be added tothe `LayerDef` optional offset, so you should probably prefer using `__pxTotalOffsetX`which contains the total offset value)
  - `:seed` - Random seed used for Auto-Layers rendering
  - `:visible` - Layer instance visibility
  """

  @enforce_keys [
    :c_hei,
    :c_wid,
    :grid_size,
    :identifier,
    :opacity,
    :px_total_offset_x,
    :px_total_offset_y,
    :type,
    :auto_layer_tiles,
    :entity_instances,
    :grid_tiles,
    :iid,
    :int_grid_csv,
    :layer_def_uid,
    :level_id,
    :optional_rules,
    :px_offset_x,
    :px_offset_y,
    :seed,
    :visible
  ]
  defstruct [
    :c_hei,
    :c_wid,
    :grid_size,
    :identifier,
    :opacity,
    :px_total_offset_x,
    :px_total_offset_y,
    :tileset_def_uid,
    :tileset_rel_path,
    :type,
    :auto_layer_tiles,
    :entity_instances,
    :grid_tiles,
    :iid,
    :int_grid,
    :int_grid_csv,
    :layer_def_uid,
    :level_id,
    :optional_rules,
    :override_tileset_uid,
    :px_offset_x,
    :px_offset_y,
    :seed,
    :visible
  ]

  @type t :: %__MODULE__{
          c_hei: integer(),
          c_wid: integer(),
          grid_size: integer(),
          identifier: String.t(),
          opacity: float(),
          px_total_offset_x: integer(),
          px_total_offset_y: integer(),
          tileset_def_uid: integer() | nil | nil,
          tileset_rel_path: nil | String.t() | nil,
          type: String.t(),
          auto_layer_tiles: [Ldtk.TileInstance.t()],
          entity_instances: [Ldtk.EntityInstance.t()],
          grid_tiles: [Ldtk.TileInstance.t()],
          iid: String.t(),
          int_grid: [Ldtk.IntGridValueInstance.t()] | nil | nil,
          int_grid_csv: [integer()],
          layer_def_uid: integer(),
          level_id: integer(),
          optional_rules: [integer()],
          override_tileset_uid: integer() | nil | nil,
          px_offset_x: integer(),
          px_offset_y: integer(),
          seed: integer(),
          visible: boolean()
        }

  def from_map(m) do
    %Ldtk.LayerInstance{
      c_hei: m["__cHei"],
      c_wid: m["__cWid"],
      grid_size: m["__gridSize"],
      identifier: m["__identifier"],
      opacity: m["__opacity"],
      px_total_offset_x: m["__pxTotalOffsetX"],
      px_total_offset_y: m["__pxTotalOffsetY"],
      tileset_def_uid: m["__tilesetDefUid"],
      tileset_rel_path: m["__tilesetRelPath"],
      type: m["__type"],
      auto_layer_tiles: Enum.map(m["autoLayerTiles"], &Ldtk.TileInstance.from_map/1),
      entity_instances: Enum.map(m["entityInstances"], &Ldtk.EntityInstance.from_map/1),
      grid_tiles: Enum.map(m["gridTiles"], &Ldtk.TileInstance.from_map/1),
      iid: m["iid"],
      int_grid: m["intGrid"] && Enum.map(m["intGrid"], &Ldtk.IntGridValueInstance.from_map/1),
      int_grid_csv: m["intGridCsv"],
      layer_def_uid: m["layerDefUid"],
      level_id: m["levelId"],
      optional_rules: m["optionalRules"],
      override_tileset_uid: m["overrideTilesetUid"],
      px_offset_x: m["pxOffsetX"],
      px_offset_y: m["pxOffsetY"],
      seed: m["seed"],
      visible: m["visible"]
    }
  end

  def from_json(json) do
    json
    |> Jason.decode!()
    |> from_map()
  end

  def to_map(struct) do
    %{
      "__cHei" => struct.c_hei,
      "__cWid" => struct.c_wid,
      "__gridSize" => struct.grid_size,
      "__identifier" => struct.identifier,
      "__opacity" => struct.opacity,
      "__pxTotalOffsetX" => struct.px_total_offset_x,
      "__pxTotalOffsetY" => struct.px_total_offset_y,
      "__tilesetDefUid" => struct.tileset_def_uid,
      "__tilesetRelPath" => struct.tileset_rel_path,
      "__type" => struct.type,
      "autoLayerTiles" =>
        struct.auto_layer_tiles && Enum.map(struct.auto_layer_tiles, &Ldtk.TileInstance.to_map/1),
      "entityInstances" =>
        struct.entity_instances &&
          Enum.map(struct.entity_instances, &Ldtk.EntityInstance.to_map/1),
      "gridTiles" =>
        struct.grid_tiles && Enum.map(struct.grid_tiles, &Ldtk.TileInstance.to_map/1),
      "iid" => struct.iid,
      "intGrid" =>
        struct.int_grid && Enum.map(struct.int_grid, &Ldtk.IntGridValueInstance.to_map/1),
      "intGridCsv" => struct.int_grid_csv,
      "layerDefUid" => struct.layer_def_uid,
      "levelId" => struct.level_id,
      "optionalRules" => struct.optional_rules,
      "overrideTilesetUid" => struct.override_tileset_uid,
      "pxOffsetX" => struct.px_offset_x,
      "pxOffsetY" => struct.px_offset_y,
      "seed" => struct.seed,
      "visible" => struct.visible
    }
  end

  def to_json(struct) do
    struct
    |> to_map()
    |> Jason.encode!()
  end
end

defmodule Ldtk.LevelBackgroundPosition do
  @moduledoc """
  Level background image position info
  - `:crop_rect` - An array of 4 float values describing the cropped sub-rectangle of the displayedbackground image. This cropping happens when original is larger than the level bounds.Array format: `[ cropX, cropY, cropWidth, cropHeight ]`
  - `:scale` - An array containing the `[scaleX,scaleY]` values of the **cropped** background image,depending on `bgPos` option.
  - `:top_left_px` - An array containing the `[x,y]` pixel coordinates of the top-left corner of the**cropped** background image, depending on `bgPos` option.
  """

  @enforce_keys [:crop_rect, :scale, :top_left_px]
  defstruct [:crop_rect, :scale, :top_left_px]

  @type t :: %__MODULE__{
          crop_rect: [float()],
          scale: [float()],
          top_left_px: [integer()]
        }

  def from_map(m) do
    %Ldtk.LevelBackgroundPosition{
      crop_rect: m["cropRect"],
      scale: m["scale"],
      top_left_px: m["topLeftPx"]
    }
  end

  def from_json(json) do
    json
    |> Jason.decode!()
    |> from_map()
  end

  def to_map(struct) do
    %{
      "cropRect" => struct.crop_rect,
      "scale" => struct.scale,
      "topLeftPx" => struct.top_left_px
    }
  end

  def to_json(struct) do
    struct
    |> to_map()
    |> Jason.encode!()
  end
end

defmodule Ldtk.BgPos do
  @valid_enum_members [
    :Contain,
    :Cover,
    :CoverDirty,
    :Repeat,
    :Unscaled
  ]

  def valid_atom?(value), do: value in @valid_enum_members

  def valid_atom_string?(value) do
    try do
      atom = String.to_existing_atom(value)
      atom in @valid_enum_members
    rescue
      ArgumentError -> false
    end
  end

  def encode(value) do
    if valid_atom?(value) do
      Atom.to_string(value)
    else
      {:error, "Unexpected value when encoding atom: #{inspect(value)}"}
    end
  end

  def decode(value) do
    if valid_atom_string?(value) do
      String.to_existing_atom(value)
    else
      {:error, "Unexpected value when decoding atom: #{inspect(value)}"}
    end
  end

  def from_json(json) do
    json
    |> Jason.decode!()
    |> decode()
  end

  def to_json(data) do
    data
    |> encode()
    |> Jason.encode!()
  end
end

defmodule Ldtk.NeighbourLevel do
  @moduledoc """
  Nearby level info
  - `:dir` - A lowercase string tipping on the level location (`n`orth, `s`outh, `w`est,`e`ast).<br/>  Since 1.4.0, this value can also be `<` (neighbour depth is lower), `>`(neighbour depth is greater) or `o` (levels overlap and share the same worlddepth).<br/>  Since 1.5.3, this value can also be `nw`,`ne`,`sw` or `se` for levels onlytouching corners.
  - `:level_iid` - Neighbour Instance Identifier
  - `:level_uid` - **WARNING**: this deprecated value is no longer exported since version 1.2.0  Replacedby: `levelIid`
  """

  @enforce_keys [:dir, :level_iid]
  defstruct [:dir, :level_iid, :level_uid]

  @type t :: %__MODULE__{
          dir: String.t(),
          level_iid: String.t(),
          level_uid: integer() | nil | nil
        }

  def from_map(m) do
    %Ldtk.NeighbourLevel{
      dir: m["dir"],
      level_iid: m["levelIid"],
      level_uid: m["levelUid"]
    }
  end

  def from_json(json) do
    json
    |> Jason.decode!()
    |> from_map()
  end

  def to_map(struct) do
    %{
      "dir" => struct.dir,
      "levelIid" => struct.level_iid,
      "levelUid" => struct.level_uid
    }
  end

  def to_json(struct) do
    struct
    |> to_map()
    |> Jason.encode!()
  end
end

defmodule Ldtk.Level do
  @moduledoc """
  This section contains all the level data. It can be found in 2 distinct forms, depending
  on Project current settings:  - If "*Separate level files*" is **disabled** (default):
  full level data is *embedded* inside the main Project JSON file, - If "*Separate level
  files*" is **enabled**: level data is stored in *separate* standalone `.ldtkl` files (one
  per level). In this case, the main Project JSON file will still contain most level data,
  except heavy sections, like the `layerInstances` array (which will be null). The
  `externalRelPath` string points to the `ldtkl` file.  A `ldtkl` file is just a JSON file
  containing exactly what is described below.
  - `:bg_color` - Background color of the level (same as `bgColor`, except the default value isautomatically used here if its value is `null`)
  - `:bg_pos` - Position informations of the background image, if there is one.
  - `:neighbours` - An array listing all other levels touching this one on the world map. Since 1.4.0, thisincludes levels that overlap in the same world layer, or in nearby world layers.<br/>Only relevant for world layouts where level spatial positioning is manual (ie. GridVania,Free). For Horizontal and Vertical layouts, this array is always empty.
  - `:smart_color` - The "guessed" color for this level in the editor, decided using either the backgroundcolor or an existing custom field.
  - `:level_bg_color` - Background color of the level. If `null`, the project `defaultLevelBgColor` should beused.
  - `:bg_pivot_x` - Background image X pivot (0-1)
  - `:bg_pivot_y` - Background image Y pivot (0-1)
  - `:level_bg_pos` - An enum defining the way the background image (if any) is positioned on the level. See`__bgPos` for resulting position info. Possible values: &lt;`null`&gt;, `Unscaled`,`Contain`, `Cover`, `CoverDirty`, `Repeat`
  - `:bg_rel_path` - The *optional* relative path to the level background image.
  - `:external_rel_path` - This value is not null if the project option "*Save levels separately*" is enabled. Inthis case, this **relative** path points to the level Json file.
  - `:field_instances` - An array containing this level custom field values.
  - `:identifier` - User defined unique identifier
  - `:iid` - Unique instance identifier
  - `:layer_instances` - An array containing all Layer instances. **IMPORTANT**: if the project option "*Savelevels separately*" is enabled, this field will be `null`.<br/>  This array is **sortedin display order**: the 1st layer is the top-most and the last is behind.
  - `:px_hei` - Height of the level in pixels
  - `:px_wid` - Width of the level in pixels
  - `:uid` - Unique Int identifier
  - `:use_auto_identifier` - If TRUE, the level identifier will always automatically use the naming pattern as definedin `Project.levelNamePattern`. Becomes FALSE if the identifier is manually modified byuser.
  - `:world_depth` - Index that represents the "depth" of the level in the world. Default is 0, greater means"above", lower means "below".<br/>  This value is mostly used for display only and isintended to make stacking of levels easier to manage.
  - `:world_x` - World X coordinate in pixels.<br/>  Only relevant for world layouts where level spatialpositioning is manual (ie. GridVania, Free). For Horizontal and Vertical layouts, thevalue is always -1 here.
  - `:world_y` - World Y coordinate in pixels.<br/>  Only relevant for world layouts where level spatialpositioning is manual (ie. GridVania, Free). For Horizontal and Vertical layouts, thevalue is always -1 here.
  """

  @enforce_keys [
    :bg_color,
    :neighbours,
    :smart_color,
    :bg_pivot_x,
    :bg_pivot_y,
    :field_instances,
    :identifier,
    :iid,
    :px_hei,
    :px_wid,
    :uid,
    :use_auto_identifier,
    :world_depth,
    :world_x,
    :world_y
  ]
  defstruct [
    :bg_color,
    :bg_pos,
    :neighbours,
    :smart_color,
    :level_bg_color,
    :bg_pivot_x,
    :bg_pivot_y,
    :level_bg_pos,
    :bg_rel_path,
    :external_rel_path,
    :field_instances,
    :identifier,
    :iid,
    :layer_instances,
    :px_hei,
    :px_wid,
    :uid,
    :use_auto_identifier,
    :world_depth,
    :world_x,
    :world_y
  ]

  @type t :: %__MODULE__{
          bg_color: String.t(),
          bg_pos: Ldtk.LevelBackgroundPosition.t() | nil | nil,
          neighbours: [Ldtk.NeighbourLevel.t()],
          smart_color: String.t(),
          level_bg_color: nil | String.t() | nil,
          bg_pivot_x: float(),
          bg_pivot_y: float(),
          level_bg_pos: Ldtk.BgPos.t() | nil | nil,
          bg_rel_path: nil | String.t() | nil,
          external_rel_path: nil | String.t() | nil,
          field_instances: [Ldtk.FieldInstance.t()],
          identifier: String.t(),
          iid: String.t(),
          layer_instances: [Ldtk.LayerInstance.t()] | nil | nil,
          px_hei: integer(),
          px_wid: integer(),
          uid: integer(),
          use_auto_identifier: boolean(),
          world_depth: integer(),
          world_x: integer(),
          world_y: integer()
        }

  def from_map(m) do
    %Ldtk.Level{
      bg_color: m["__bgColor"],
      bg_pos: m["__bgPos"] && Ldtk.LevelBackgroundPosition.from_map(m["__bgPos"]),
      neighbours: Enum.map(m["__neighbours"], &Ldtk.NeighbourLevel.from_map/1),
      smart_color: m["__smartColor"],
      level_bg_color: m["bgColor"],
      bg_pivot_x: m["bgPivotX"],
      bg_pivot_y: m["bgPivotY"],
      level_bg_pos: m["bgPos"] && Ldtk.BgPos.decode(m["bgPos"]),
      bg_rel_path: m["bgRelPath"],
      external_rel_path: m["externalRelPath"],
      field_instances: Enum.map(m["fieldInstances"], &Ldtk.FieldInstance.from_map/1),
      identifier: m["identifier"],
      iid: m["iid"],
      layer_instances:
        m["layerInstances"] && Enum.map(m["layerInstances"], &Ldtk.LayerInstance.from_map/1),
      px_hei: m["pxHei"],
      px_wid: m["pxWid"],
      uid: m["uid"],
      use_auto_identifier: m["useAutoIdentifier"],
      world_depth: m["worldDepth"],
      world_x: m["worldX"],
      world_y: m["worldY"]
    }
  end

  def from_json(json) do
    json
    |> Jason.decode!()
    |> from_map()
  end

  def to_map(struct) do
    %{
      "__bgColor" => struct.bg_color,
      "__bgPos" => struct.bg_pos && Ldtk.LevelBackgroundPosition.to_map(struct.bg_pos),
      "__neighbours" =>
        struct.neighbours && Enum.map(struct.neighbours, &Ldtk.NeighbourLevel.to_map/1),
      "__smartColor" => struct.smart_color,
      "bgColor" => struct.level_bg_color,
      "bgPivotX" => struct.bg_pivot_x,
      "bgPivotY" => struct.bg_pivot_y,
      "bgPos" => struct.level_bg_pos && Ldtk.BgPos.encode(struct.level_bg_pos),
      "bgRelPath" => struct.bg_rel_path,
      "externalRelPath" => struct.external_rel_path,
      "fieldInstances" =>
        struct.field_instances && Enum.map(struct.field_instances, &Ldtk.FieldInstance.to_map/1),
      "identifier" => struct.identifier,
      "iid" => struct.iid,
      "layerInstances" =>
        struct.layer_instances && Enum.map(struct.layer_instances, &Ldtk.LayerInstance.to_map/1),
      "pxHei" => struct.px_hei,
      "pxWid" => struct.px_wid,
      "uid" => struct.uid,
      "useAutoIdentifier" => struct.use_auto_identifier,
      "worldDepth" => struct.world_depth,
      "worldX" => struct.world_x,
      "worldY" => struct.world_y
    }
  end

  def to_json(struct) do
    struct
    |> to_map()
    |> Jason.encode!()
  end
end

defmodule Ldtk.LdtkTocInstanceData do
  @moduledoc """
  - `:fields` - An object containing the values of all entity fields with the `exportToToc` optionenabled. This object typing depends on actual field value types.
  - `:iids` - IID information of this instance
  """

  @enforce_keys [:fields, :hei_px, :iids, :wid_px, :world_x, :world_y]
  defstruct [:fields, :hei_px, :iids, :wid_px, :world_x, :world_y]

  @type t :: %__MODULE__{
          fields: any(),
          hei_px: integer(),
          iids: Ldtk.ReferenceToAnEntityInstance.t(),
          wid_px: integer(),
          world_x: integer(),
          world_y: integer()
        }

  def from_map(m) do
    %Ldtk.LdtkTocInstanceData{
      fields: m["fields"],
      hei_px: m["heiPx"],
      iids: Ldtk.ReferenceToAnEntityInstance.from_map(m["iids"]),
      wid_px: m["widPx"],
      world_x: m["worldX"],
      world_y: m["worldY"]
    }
  end

  def from_json(json) do
    json
    |> Jason.decode!()
    |> from_map()
  end

  def to_map(struct) do
    %{
      "fields" => struct.fields,
      "heiPx" => struct.hei_px,
      "iids" => Ldtk.ReferenceToAnEntityInstance.to_map(struct.iids),
      "widPx" => struct.wid_px,
      "worldX" => struct.world_x,
      "worldY" => struct.world_y
    }
  end

  def to_json(struct) do
    struct
    |> to_map()
    |> Jason.encode!()
  end
end

defmodule Ldtk.LdtkTableOfContentEntry do
  @moduledoc """
  - `:instances` - **WARNING**: this deprecated value will be *removed* completely on version 1.7.0+Replaced by: `instancesData`
  """

  @enforce_keys [:identifier, :instances_data]
  defstruct [:identifier, :instances, :instances_data]

  @type t :: %__MODULE__{
          identifier: String.t(),
          instances: [Ldtk.ReferenceToAnEntityInstance.t()] | nil,
          instances_data: [Ldtk.LdtkTocInstanceData.t()]
        }

  def from_map(m) do
    %Ldtk.LdtkTableOfContentEntry{
      identifier: m["identifier"],
      instances:
        m["instances"] && Enum.map(m["instances"], &Ldtk.ReferenceToAnEntityInstance.from_map/1),
      instances_data: Enum.map(m["instancesData"], &Ldtk.LdtkTocInstanceData.from_map/1)
    }
  end

  def from_json(json) do
    json
    |> Jason.decode!()
    |> from_map()
  end

  def to_map(struct) do
    %{
      "identifier" => struct.identifier,
      "instances" =>
        struct.instances && Enum.map(struct.instances, &Ldtk.ReferenceToAnEntityInstance.to_map/1),
      "instancesData" =>
        struct.instances_data &&
          Enum.map(struct.instances_data, &Ldtk.LdtkTocInstanceData.to_map/1)
    }
  end

  def to_json(struct) do
    struct
    |> to_map()
    |> Jason.encode!()
  end
end

defmodule Ldtk.WorldLayout do
  @valid_enum_members [
    :Free,
    :GridVania,
    :LinearHorizontal,
    :LinearVertical
  ]

  def valid_atom?(value), do: value in @valid_enum_members

  def valid_atom_string?(value) do
    try do
      atom = String.to_existing_atom(value)
      atom in @valid_enum_members
    rescue
      ArgumentError -> false
    end
  end

  def encode(value) do
    if valid_atom?(value) do
      Atom.to_string(value)
    else
      {:error, "Unexpected value when encoding atom: #{inspect(value)}"}
    end
  end

  def decode(value) do
    if valid_atom_string?(value) do
      String.to_existing_atom(value)
    else
      {:error, "Unexpected value when decoding atom: #{inspect(value)}"}
    end
  end

  def from_json(json) do
    json
    |> Jason.decode!()
    |> decode()
  end

  def to_json(data) do
    data
    |> encode()
    |> Jason.encode!()
  end
end

defmodule Ldtk.World do
  @moduledoc """
  **IMPORTANT**: this type is available as a preview. You can rely on it to update your
  importers, for when it will be officially available.  A World contains multiple levels,
  and it has its own layout settings.
  - `:default_level_height` - Default new level height
  - `:default_level_width` - Default new level width
  - `:identifier` - User defined unique identifier
  - `:iid` - Unique instance identifer
  - `:levels` - All levels from this world. The order of this array is only relevant in`LinearHorizontal` and `linearVertical` world layouts (see `worldLayout` value).Otherwise, you should refer to the `worldX`,`worldY` coordinates of each Level.
  - `:world_grid_height` - Height of the world grid in pixels.
  - `:world_grid_width` - Width of the world grid in pixels.
  - `:world_layout` - An enum that describes how levels are organized in this project (ie. linearly or in a 2Dspace). Possible values: `Free`, `GridVania`, `LinearHorizontal`, `LinearVertical`, `null`
  """

  @enforce_keys [
    :default_level_height,
    :default_level_width,
    :identifier,
    :iid,
    :levels,
    :world_grid_height,
    :world_grid_width,
    :world_layout
  ]
  defstruct [
    :default_level_height,
    :default_level_width,
    :identifier,
    :iid,
    :levels,
    :world_grid_height,
    :world_grid_width,
    :world_layout
  ]

  @type t :: %__MODULE__{
          default_level_height: integer(),
          default_level_width: integer(),
          identifier: String.t(),
          iid: String.t(),
          levels: [Ldtk.Level.t()],
          world_grid_height: integer(),
          world_grid_width: integer(),
          world_layout: Ldtk.WorldLayout.t() | nil
        }

  def from_map(m) do
    %Ldtk.World{
      default_level_height: m["defaultLevelHeight"],
      default_level_width: m["defaultLevelWidth"],
      identifier: m["identifier"],
      iid: m["iid"],
      levels: Enum.map(m["levels"], &Ldtk.Level.from_map/1),
      world_grid_height: m["worldGridHeight"],
      world_grid_width: m["worldGridWidth"],
      world_layout: m["worldLayout"] && Ldtk.WorldLayout.decode(m["worldLayout"])
    }
  end

  def from_json(json) do
    json
    |> Jason.decode!()
    |> from_map()
  end

  def to_map(struct) do
    %{
      "defaultLevelHeight" => struct.default_level_height,
      "defaultLevelWidth" => struct.default_level_width,
      "identifier" => struct.identifier,
      "iid" => struct.iid,
      "levels" => struct.levels && Enum.map(struct.levels, &Ldtk.Level.to_map/1),
      "worldGridHeight" => struct.world_grid_height,
      "worldGridWidth" => struct.world_grid_width,
      "worldLayout" => struct.world_layout && Ldtk.WorldLayout.encode(struct.world_layout)
    }
  end

  def to_json(struct) do
    struct
    |> to_map()
    |> Jason.encode!()
  end
end

defmodule Ldtk.ForcedRefs do
  @moduledoc """
  This object is not actually used by LDtk. It ONLY exists to force explicit references to
  all types, to make sure QuickType finds them and integrate all of them. Otherwise,
  Quicktype will drop types that are not explicitely used.
  """

  defstruct [
    :auto_layer_rule_group,
    :auto_rule_def,
    :custom_command,
    :definitions,
    :entity_def,
    :entity_instance,
    :entity_reference_infos,
    :enum_def,
    :enum_def_values,
    :enum_tag_value,
    :field_def,
    :field_instance,
    :grid_point,
    :int_grid_value_def,
    :int_grid_value_group_def,
    :int_grid_value_instance,
    :layer_def,
    :layer_instance,
    :level,
    :level_bg_pos_infos,
    :neighbour_level,
    :table_of_content_entry,
    :tile,
    :tile_custom_metadata,
    :tileset_def,
    :tileset_rect,
    :toc_instance_data,
    :world
  ]

  @type t :: %__MODULE__{
          auto_layer_rule_group: Ldtk.AutoLayerRuleGroup.t() | nil,
          auto_rule_def: Ldtk.AutoLayerRuleDefinition.t() | nil,
          custom_command: Ldtk.LdtkCustomCommand.t() | nil,
          definitions: Ldtk.Definitions.t() | nil,
          entity_def: Ldtk.EntityDefinition.t() | nil,
          entity_instance: Ldtk.EntityInstance.t() | nil,
          entity_reference_infos: Ldtk.ReferenceToAnEntityInstance.t() | nil,
          enum_def: Ldtk.EnumDefinition.t() | nil,
          enum_def_values: Ldtk.EnumValueDefinition.t() | nil,
          enum_tag_value: Ldtk.EnumTagValue.t() | nil,
          field_def: Ldtk.FieldDefinition.t() | nil,
          field_instance: Ldtk.FieldInstance.t() | nil,
          grid_point: Ldtk.GridPoint.t() | nil,
          int_grid_value_def: Ldtk.IntGridValueDefinition.t() | nil,
          int_grid_value_group_def: Ldtk.IntGridValueGroupDefinition.t() | nil,
          int_grid_value_instance: Ldtk.IntGridValueInstance.t() | nil,
          layer_def: Ldtk.LayerDefinition.t() | nil,
          layer_instance: Ldtk.LayerInstance.t() | nil,
          level: Ldtk.Level.t() | nil,
          level_bg_pos_infos: Ldtk.LevelBackgroundPosition.t() | nil,
          neighbour_level: Ldtk.NeighbourLevel.t() | nil,
          table_of_content_entry: Ldtk.LdtkTableOfContentEntry.t() | nil,
          tile: Ldtk.TileInstance.t() | nil,
          tile_custom_metadata: Ldtk.TileCustomMetadata.t() | nil,
          tileset_def: Ldtk.TilesetDefinition.t() | nil,
          tileset_rect: Ldtk.TilesetRectangle.t() | nil,
          toc_instance_data: Ldtk.LdtkTocInstanceData.t() | nil,
          world: Ldtk.World.t() | nil
        }

  def from_map(m) do
    %Ldtk.ForcedRefs{
      auto_layer_rule_group:
        m["AutoLayerRuleGroup"] && Ldtk.AutoLayerRuleGroup.from_map(m["AutoLayerRuleGroup"]),
      auto_rule_def: m["AutoRuleDef"] && Ldtk.AutoLayerRuleDefinition.from_map(m["AutoRuleDef"]),
      custom_command: m["CustomCommand"] && Ldtk.LdtkCustomCommand.from_map(m["CustomCommand"]),
      definitions: m["Definitions"] && Ldtk.Definitions.from_map(m["Definitions"]),
      entity_def: m["EntityDef"] && Ldtk.EntityDefinition.from_map(m["EntityDef"]),
      entity_instance: m["EntityInstance"] && Ldtk.EntityInstance.from_map(m["EntityInstance"]),
      entity_reference_infos:
        m["EntityReferenceInfos"] &&
          Ldtk.ReferenceToAnEntityInstance.from_map(m["EntityReferenceInfos"]),
      enum_def: m["EnumDef"] && Ldtk.EnumDefinition.from_map(m["EnumDef"]),
      enum_def_values:
        m["EnumDefValues"] && Ldtk.EnumValueDefinition.from_map(m["EnumDefValues"]),
      enum_tag_value: m["EnumTagValue"] && Ldtk.EnumTagValue.from_map(m["EnumTagValue"]),
      field_def: m["FieldDef"] && Ldtk.FieldDefinition.from_map(m["FieldDef"]),
      field_instance: m["FieldInstance"] && Ldtk.FieldInstance.from_map(m["FieldInstance"]),
      grid_point: m["GridPoint"] && Ldtk.GridPoint.from_map(m["GridPoint"]),
      int_grid_value_def:
        m["IntGridValueDef"] && Ldtk.IntGridValueDefinition.from_map(m["IntGridValueDef"]),
      int_grid_value_group_def:
        m["IntGridValueGroupDef"] &&
          Ldtk.IntGridValueGroupDefinition.from_map(m["IntGridValueGroupDef"]),
      int_grid_value_instance:
        m["IntGridValueInstance"] && Ldtk.IntGridValueInstance.from_map(m["IntGridValueInstance"]),
      layer_def: m["LayerDef"] && Ldtk.LayerDefinition.from_map(m["LayerDef"]),
      layer_instance: m["LayerInstance"] && Ldtk.LayerInstance.from_map(m["LayerInstance"]),
      level: m["Level"] && Ldtk.Level.from_map(m["Level"]),
      level_bg_pos_infos:
        m["LevelBgPosInfos"] && Ldtk.LevelBackgroundPosition.from_map(m["LevelBgPosInfos"]),
      neighbour_level: m["NeighbourLevel"] && Ldtk.NeighbourLevel.from_map(m["NeighbourLevel"]),
      table_of_content_entry:
        m["TableOfContentEntry"] &&
          Ldtk.LdtkTableOfContentEntry.from_map(m["TableOfContentEntry"]),
      tile: m["Tile"] && Ldtk.TileInstance.from_map(m["Tile"]),
      tile_custom_metadata:
        m["TileCustomMetadata"] && Ldtk.TileCustomMetadata.from_map(m["TileCustomMetadata"]),
      tileset_def: m["TilesetDef"] && Ldtk.TilesetDefinition.from_map(m["TilesetDef"]),
      tileset_rect: m["TilesetRect"] && Ldtk.TilesetRectangle.from_map(m["TilesetRect"]),
      toc_instance_data:
        m["TocInstanceData"] && Ldtk.LdtkTocInstanceData.from_map(m["TocInstanceData"]),
      world: m["World"] && Ldtk.World.from_map(m["World"])
    }
  end

  def from_json(json) do
    json
    |> Jason.decode!()
    |> from_map()
  end

  def to_map(struct) do
    %{
      "AutoLayerRuleGroup" =>
        struct.auto_layer_rule_group &&
          Ldtk.AutoLayerRuleGroup.to_map(struct.auto_layer_rule_group),
      "AutoRuleDef" =>
        struct.auto_rule_def && Ldtk.AutoLayerRuleDefinition.to_map(struct.auto_rule_def),
      "CustomCommand" =>
        struct.custom_command && Ldtk.LdtkCustomCommand.to_map(struct.custom_command),
      "Definitions" => struct.definitions && Ldtk.Definitions.to_map(struct.definitions),
      "EntityDef" => struct.entity_def && Ldtk.EntityDefinition.to_map(struct.entity_def),
      "EntityInstance" =>
        struct.entity_instance && Ldtk.EntityInstance.to_map(struct.entity_instance),
      "EntityReferenceInfos" =>
        struct.entity_reference_infos &&
          Ldtk.ReferenceToAnEntityInstance.to_map(struct.entity_reference_infos),
      "EnumDef" => struct.enum_def && Ldtk.EnumDefinition.to_map(struct.enum_def),
      "EnumDefValues" =>
        struct.enum_def_values && Ldtk.EnumValueDefinition.to_map(struct.enum_def_values),
      "EnumTagValue" => struct.enum_tag_value && Ldtk.EnumTagValue.to_map(struct.enum_tag_value),
      "FieldDef" => struct.field_def && Ldtk.FieldDefinition.to_map(struct.field_def),
      "FieldInstance" =>
        struct.field_instance && Ldtk.FieldInstance.to_map(struct.field_instance),
      "GridPoint" => struct.grid_point && Ldtk.GridPoint.to_map(struct.grid_point),
      "IntGridValueDef" =>
        struct.int_grid_value_def && Ldtk.IntGridValueDefinition.to_map(struct.int_grid_value_def),
      "IntGridValueGroupDef" =>
        struct.int_grid_value_group_def &&
          Ldtk.IntGridValueGroupDefinition.to_map(struct.int_grid_value_group_def),
      "IntGridValueInstance" =>
        struct.int_grid_value_instance &&
          Ldtk.IntGridValueInstance.to_map(struct.int_grid_value_instance),
      "LayerDef" => struct.layer_def && Ldtk.LayerDefinition.to_map(struct.layer_def),
      "LayerInstance" =>
        struct.layer_instance && Ldtk.LayerInstance.to_map(struct.layer_instance),
      "Level" => struct.level && Ldtk.Level.to_map(struct.level),
      "LevelBgPosInfos" =>
        struct.level_bg_pos_infos &&
          Ldtk.LevelBackgroundPosition.to_map(struct.level_bg_pos_infos),
      "NeighbourLevel" =>
        struct.neighbour_level && Ldtk.NeighbourLevel.to_map(struct.neighbour_level),
      "TableOfContentEntry" =>
        struct.table_of_content_entry &&
          Ldtk.LdtkTableOfContentEntry.to_map(struct.table_of_content_entry),
      "Tile" => struct.tile && Ldtk.TileInstance.to_map(struct.tile),
      "TileCustomMetadata" =>
        struct.tile_custom_metadata && Ldtk.TileCustomMetadata.to_map(struct.tile_custom_metadata),
      "TilesetDef" => struct.tileset_def && Ldtk.TilesetDefinition.to_map(struct.tileset_def),
      "TilesetRect" => struct.tileset_rect && Ldtk.TilesetRectangle.to_map(struct.tileset_rect),
      "TocInstanceData" =>
        struct.toc_instance_data && Ldtk.LdtkTocInstanceData.to_map(struct.toc_instance_data),
      "World" => struct.world && Ldtk.World.to_map(struct.world)
    }
  end

  def to_json(struct) do
    struct
    |> to_map()
    |> Jason.encode!()
  end
end

defmodule Ldtk.IdentifierStyle do
  @moduledoc """
  Naming convention for Identifiers (first-letter uppercase, full uppercase etc.) Possible
  values: `Capitalize`, `Uppercase`, `Lowercase`, `Free`
  """
  @valid_enum_members [
    :Capitalize,
    :Free,
    :Lowercase,
    :Uppercase
  ]

  def valid_atom?(value), do: value in @valid_enum_members

  def valid_atom_string?(value) do
    try do
      atom = String.to_existing_atom(value)
      atom in @valid_enum_members
    rescue
      ArgumentError -> false
    end
  end

  def encode(value) do
    if valid_atom?(value) do
      Atom.to_string(value)
    else
      {:error, "Unexpected value when encoding atom: #{inspect(value)}"}
    end
  end

  def decode(value) do
    if valid_atom_string?(value) do
      String.to_existing_atom(value)
    else
      {:error, "Unexpected value when decoding atom: #{inspect(value)}"}
    end
  end

  def from_json(json) do
    json
    |> Jason.decode!()
    |> decode()
  end

  def to_json(data) do
    data
    |> encode()
    |> Jason.encode!()
  end
end

defmodule Ldtk.ImageExportMode do
  @moduledoc """
  "Image export" option when saving project. Possible values: `None`, `OneImagePerLayer`,
  `OneImagePerLevel`, `LayersAndLevels`
  """
  @valid_enum_members [
    :LayersAndLevels,
    :None,
    :OneImagePerLayer,
    :OneImagePerLevel
  ]

  def valid_atom?(value), do: value in @valid_enum_members

  def valid_atom_string?(value) do
    try do
      atom = String.to_existing_atom(value)
      atom in @valid_enum_members
    rescue
      ArgumentError -> false
    end
  end

  def encode(value) do
    if valid_atom?(value) do
      Atom.to_string(value)
    else
      {:error, "Unexpected value when encoding atom: #{inspect(value)}"}
    end
  end

  def decode(value) do
    if valid_atom_string?(value) do
      String.to_existing_atom(value)
    else
      {:error, "Unexpected value when decoding atom: #{inspect(value)}"}
    end
  end

  def from_json(json) do
    json
    |> Jason.decode!()
    |> decode()
  end

  def to_json(data) do
    data
    |> encode()
    |> Jason.encode!()
  end
end

defmodule Ldtk.Root do
  @moduledoc """
  This file is a JSON schema of files created by LDtk level editor (https://ldtk.io).

  This is the root of any Project JSON file. It contains:  - the project settings, - an
  array of levels, - a group of definitions (that can probably be safely ignored for most
  users).
  - `:forced_refs` - This object is not actually used by LDtk. It ONLY exists to force explicit references toall types, to make sure QuickType finds them and integrate all of them. Otherwise,Quicktype will drop types that are not explicitely used.
  - `:app_build_id` - LDtk application build identifier.<br/>  This is only used to identify the LDtk versionthat generated this particular project file, which can be useful for specific bug fixing.Note that the build identifier is just the date of the release, so it's not unique toeach user (one single global ID per LDtk public release), and as a result, completelyanonymous.
  - `:backup_limit` - Number of backup files to keep, if the `backupOnSave` is TRUE
  - `:backup_on_save` - If TRUE, an extra copy of the project will be created in a sub folder, when saving.
  - `:backup_rel_path` - Target relative path to store backup files
  - `:bg_color` - Project background color
  - `:custom_commands` - An array of command lines that can be ran manually by the user
  - `:default_entity_height` - Default height for new entities
  - `:default_entity_width` - Default width for new entities
  - `:default_grid_size` - Default grid size for new layers
  - `:default_level_bg_color` - Default background color of levels
  - `:default_level_height` - **WARNING**: this field will move to the `worlds` array after the "multi-worlds" update.It will then be `null`. You can enable the Multi-worlds advanced project option to enablethe change immediately.<br/><br/>  Default new level height
  - `:default_level_width` - **WARNING**: this field will move to the `worlds` array after the "multi-worlds" update.It will then be `null`. You can enable the Multi-worlds advanced project option to enablethe change immediately.<br/><br/>  Default new level width
  - `:default_pivot_x` - Default X pivot (0 to 1) for new entities
  - `:default_pivot_y` - Default Y pivot (0 to 1) for new entities
  - `:defs` - A structure containing all the definitions of this project
  - `:dummy_world_iid` - If the project isn't in MultiWorlds mode, this is the IID of the internal "dummy" World.
  - `:export_level_bg` - If TRUE, the exported PNGs will include the level background (color or image).
  - `:export_png` - **WARNING**: this deprecated value is no longer exported since version 0.9.3  Replacedby: `imageExportMode`
  - `:export_tiled` - If TRUE, a Tiled compatible file will also be generated along with the LDtk JSON file(default is FALSE)
  - `:external_levels` - If TRUE, one file will be saved for the project (incl. all its definitions) and one filein a sub-folder for each level.
  - `:flags` - An array containing various advanced flags (ie. options or other states). Possiblevalues: `DiscardPreCsvIntGrid`, `ExportOldTableOfContentData`,`ExportPreCsvIntGridFormat`, `IgnoreBackupSuggest`, `PrependIndexToLevelFileNames`,`MultiWorlds`, `UseMultilinesType`
  - `:identifier_style` - Naming convention for Identifiers (first-letter uppercase, full uppercase etc.) Possiblevalues: `Capitalize`, `Uppercase`, `Lowercase`, `Free`
  - `:iid` - Unique project identifier
  - `:image_export_mode` - "Image export" option when saving project. Possible values: `None`, `OneImagePerLayer`,`OneImagePerLevel`, `LayersAndLevels`
  - `:json_version` - File format version
  - `:level_name_pattern` - The default naming convention for level identifiers.
  - `:levels` - All levels. The order of this array is only relevant in `LinearHorizontal` and`linearVertical` world layouts (see `worldLayout` value).<br/>  Otherwise, you shouldrefer to the `worldX`,`worldY` coordinates of each Level.
  - `:minify_json` - If TRUE, the Json is partially minified (no indentation, nor line breaks, default isFALSE)
  - `:next_uid` - Next Unique integer ID available
  - `:png_file_pattern` - File naming pattern for exported PNGs
  - `:simplified_export` - If TRUE, a very simplified will be generated on saving, for quicker & easier engineintegration.
  - `:toc` - All instances of entities that have their `exportToToc` flag enabled are listed in thisarray.
  - `:tutorial_desc` - This optional description is used by LDtk Samples to show up some informations andinstructions.
  - `:world_grid_height` - **WARNING**: this field will move to the `worlds` array after the "multi-worlds" update.It will then be `null`. You can enable the Multi-worlds advanced project option to enablethe change immediately.<br/><br/>  Height of the world grid in pixels.
  - `:world_grid_width` - **WARNING**: this field will move to the `worlds` array after the "multi-worlds" update.It will then be `null`. You can enable the Multi-worlds advanced project option to enablethe change immediately.<br/><br/>  Width of the world grid in pixels.
  - `:world_layout` - **WARNING**: this field will move to the `worlds` array after the "multi-worlds" update.It will then be `null`. You can enable the Multi-worlds advanced project option to enablethe change immediately.<br/><br/>  An enum that describes how levels are organized inthis project (ie. linearly or in a 2D space). Possible values: &lt;`null`&gt;, `Free`,`GridVania`, `LinearHorizontal`, `LinearVertical`
  - `:worlds` - This array will be empty, unless you enable the Multi-Worlds in the project advancedsettings.<br/><br/> - in current version, a LDtk project file can only contain a singleworld with multiple levels in it. In this case, levels and world layout related settingsare stored in the root of the JSON.<br/> - with "Multi-worlds" enabled, there will be a`worlds` array in root, each world containing levels and layout settings. Basically, it'spretty much only about moving the `levels` array to the `worlds` array, along with worldlayout related values (eg. `worldGridWidth` etc).<br/><br/>If you want to startsupporting this future update easily, please refer to this documentation:https://github.com/deepnight/ldtk/issues/231
  """

  @enforce_keys [
    :app_build_id,
    :backup_limit,
    :backup_on_save,
    :bg_color,
    :custom_commands,
    :default_entity_height,
    :default_entity_width,
    :default_grid_size,
    :default_level_bg_color,
    :default_pivot_x,
    :default_pivot_y,
    :defs,
    :dummy_world_iid,
    :export_level_bg,
    :export_tiled,
    :external_levels,
    :flags,
    :identifier_style,
    :iid,
    :image_export_mode,
    :json_version,
    :level_name_pattern,
    :levels,
    :minify_json,
    :next_uid,
    :simplified_export,
    :toc,
    :worlds
  ]
  defstruct [
    :forced_refs,
    :app_build_id,
    :backup_limit,
    :backup_on_save,
    :backup_rel_path,
    :bg_color,
    :custom_commands,
    :default_entity_height,
    :default_entity_width,
    :default_grid_size,
    :default_level_bg_color,
    :default_level_height,
    :default_level_width,
    :default_pivot_x,
    :default_pivot_y,
    :defs,
    :dummy_world_iid,
    :export_level_bg,
    :export_png,
    :export_tiled,
    :external_levels,
    :flags,
    :identifier_style,
    :iid,
    :image_export_mode,
    :json_version,
    :level_name_pattern,
    :levels,
    :minify_json,
    :next_uid,
    :png_file_pattern,
    :simplified_export,
    :toc,
    :tutorial_desc,
    :world_grid_height,
    :world_grid_width,
    :world_layout,
    :worlds
  ]

  @type t :: %__MODULE__{
          forced_refs: Ldtk.ForcedRefs.t() | nil,
          app_build_id: float(),
          backup_limit: integer(),
          backup_on_save: boolean(),
          backup_rel_path: nil | String.t() | nil,
          bg_color: String.t(),
          custom_commands: [Ldtk.LdtkCustomCommand.t()],
          default_entity_height: integer(),
          default_entity_width: integer(),
          default_grid_size: integer(),
          default_level_bg_color: String.t(),
          default_level_height: integer() | nil | nil,
          default_level_width: integer() | nil | nil,
          default_pivot_x: float(),
          default_pivot_y: float(),
          defs: Ldtk.Definitions.t(),
          dummy_world_iid: String.t(),
          export_level_bg: boolean(),
          export_png: boolean() | nil | nil,
          export_tiled: boolean(),
          external_levels: boolean(),
          flags: [Ldtk.Flag.t()],
          identifier_style: Ldtk.IdentifierStyle.t(),
          iid: String.t(),
          image_export_mode: Ldtk.ImageExportMode.t(),
          json_version: String.t(),
          level_name_pattern: String.t(),
          levels: [Ldtk.Level.t()],
          minify_json: boolean(),
          next_uid: integer(),
          png_file_pattern: nil | String.t() | nil,
          simplified_export: boolean(),
          toc: [Ldtk.LdtkTableOfContentEntry.t()],
          tutorial_desc: nil | String.t() | nil,
          world_grid_height: integer() | nil | nil,
          world_grid_width: integer() | nil | nil,
          world_layout: Ldtk.WorldLayout.t() | nil | nil,
          worlds: [Ldtk.World.t()]
        }

  def from_map(m) do
    %Ldtk.Root{
      forced_refs: m["__FORCED_REFS"] && Ldtk.ForcedRefs.from_map(m["__FORCED_REFS"]),
      app_build_id: m["appBuildId"],
      backup_limit: m["backupLimit"],
      backup_on_save: m["backupOnSave"],
      backup_rel_path: m["backupRelPath"],
      bg_color: m["bgColor"],
      custom_commands: Enum.map(m["customCommands"], &Ldtk.LdtkCustomCommand.from_map/1),
      default_entity_height: m["defaultEntityHeight"],
      default_entity_width: m["defaultEntityWidth"],
      default_grid_size: m["defaultGridSize"],
      default_level_bg_color: m["defaultLevelBgColor"],
      default_level_height: m["defaultLevelHeight"],
      default_level_width: m["defaultLevelWidth"],
      default_pivot_x: m["defaultPivotX"],
      default_pivot_y: m["defaultPivotY"],
      defs: Ldtk.Definitions.from_map(m["defs"]),
      dummy_world_iid: m["dummyWorldIid"],
      export_level_bg: m["exportLevelBg"],
      export_png: m["exportPng"],
      export_tiled: m["exportTiled"],
      external_levels: m["externalLevels"],
      flags: Enum.map(m["flags"], &Ldtk.Flag.decode/1),
      identifier_style: Ldtk.IdentifierStyle.decode(m["identifierStyle"]),
      iid: m["iid"],
      image_export_mode: Ldtk.ImageExportMode.decode(m["imageExportMode"]),
      json_version: m["jsonVersion"],
      level_name_pattern: m["levelNamePattern"],
      levels: Enum.map(m["levels"], &Ldtk.Level.from_map/1),
      minify_json: m["minifyJson"],
      next_uid: m["nextUid"],
      png_file_pattern: m["pngFilePattern"],
      simplified_export: m["simplifiedExport"],
      toc: Enum.map(m["toc"], &Ldtk.LdtkTableOfContentEntry.from_map/1),
      tutorial_desc: m["tutorialDesc"],
      world_grid_height: m["worldGridHeight"],
      world_grid_width: m["worldGridWidth"],
      world_layout: m["worldLayout"] && Ldtk.WorldLayout.decode(m["worldLayout"]),
      worlds: Enum.map(m["worlds"], &Ldtk.World.from_map/1)
    }
  end

  def from_json(json) do
    json
    |> Jason.decode!()
    |> from_map()
  end

  def to_map(struct) do
    %{
      "__FORCED_REFS" => struct.forced_refs && Ldtk.ForcedRefs.to_map(struct.forced_refs),
      "appBuildId" => struct.app_build_id,
      "backupLimit" => struct.backup_limit,
      "backupOnSave" => struct.backup_on_save,
      "backupRelPath" => struct.backup_rel_path,
      "bgColor" => struct.bg_color,
      "customCommands" =>
        struct.custom_commands &&
          Enum.map(struct.custom_commands, &Ldtk.LdtkCustomCommand.to_map/1),
      "defaultEntityHeight" => struct.default_entity_height,
      "defaultEntityWidth" => struct.default_entity_width,
      "defaultGridSize" => struct.default_grid_size,
      "defaultLevelBgColor" => struct.default_level_bg_color,
      "defaultLevelHeight" => struct.default_level_height,
      "defaultLevelWidth" => struct.default_level_width,
      "defaultPivotX" => struct.default_pivot_x,
      "defaultPivotY" => struct.default_pivot_y,
      "defs" => Ldtk.Definitions.to_map(struct.defs),
      "dummyWorldIid" => struct.dummy_world_iid,
      "exportLevelBg" => struct.export_level_bg,
      "exportPng" => struct.export_png,
      "exportTiled" => struct.export_tiled,
      "externalLevels" => struct.external_levels,
      "flags" => struct.flags && Enum.map(struct.flags, &Ldtk.Flag.encode/1),
      "identifierStyle" => Ldtk.IdentifierStyle.encode(struct.identifier_style),
      "iid" => struct.iid,
      "imageExportMode" => Ldtk.ImageExportMode.encode(struct.image_export_mode),
      "jsonVersion" => struct.json_version,
      "levelNamePattern" => struct.level_name_pattern,
      "levels" => struct.levels && Enum.map(struct.levels, &Ldtk.Level.to_map/1),
      "minifyJson" => struct.minify_json,
      "nextUid" => struct.next_uid,
      "pngFilePattern" => struct.png_file_pattern,
      "simplifiedExport" => struct.simplified_export,
      "toc" => struct.toc && Enum.map(struct.toc, &Ldtk.LdtkTableOfContentEntry.to_map/1),
      "tutorialDesc" => struct.tutorial_desc,
      "worldGridHeight" => struct.world_grid_height,
      "worldGridWidth" => struct.world_grid_width,
      "worldLayout" => struct.world_layout && Ldtk.WorldLayout.encode(struct.world_layout),
      "worlds" => struct.worlds && Enum.map(struct.worlds, &Ldtk.World.to_map/1)
    }
  end

  def to_json(struct) do
    struct
    |> to_map()
    |> Jason.encode!()
  end
end
